@@directive("import internalConfigJson from '../internal.config.json' with { type: 'json' }")

// All event getRegisteredHandler functions - used to collect registered handlers
let allEventGetRegisteredHandlers: array<(string, unit => Internal.registeredHandler)> = [
  {{#each chain_configs as | chain_config |}}
  {{#each chain_config.codegen_contracts as | contract |}}
  {{#each contract.events as | event |}}
  (Types.{{contract.name.capitalized}}.{{event.name}}.id, Types.{{contract.name.capitalized}}.{{event.name}}.getRegisteredHandler),
  {{/each}}
  {{/each}}
  {{/each}}
]

// Collect all registered handlers into a dict by event id
let collectRegisteredHandlers = (): dict<Internal.registeredHandler> => {
  let handlers = Js.Dict.empty()
  allEventGetRegisteredHandlers->Belt.Array.forEach(((eventId, getRegisteredHandler)) => {
    handlers->Js.Dict.set(eventId, getRegisteredHandler())
  })
  handlers
}

let makeGeneratedConfig = (~registeredHandlers: dict<Internal.registeredHandler>=Js.Dict.empty()) => {
  let codegenChains = [
    {{#each chain_configs as | chain_config |}}
    {
      let contracts = [
        {{#each chain_config.codegen_contracts as | contract |}}
        {
          Config.name: "{{contract.name.capitalized}}",
          addresses: [
            {{#each contract.addresses as | address |}}
            "{{address}}",
            {{/each}}
          ],
          events: [
            {{#each contract.events as | event |}}
            (Types.{{contract.name.capitalized}}.{{event.name}}.register() :> Internal.eventConfig),
            {{/each}}
          ],
          startBlock: {{#if contract.start_block}}Some({{contract.start_block}}){{else}}None{{/if}},
        },
        {{/each}}
      ]
      let chain = ChainMap.Chain.makeUnsafe(~chainId={{chain_config.network_config.id}})
      {
        Config.id: {{chain_config.network_config.id}},
        contracts,
        sources: {{chain_config.sources_code}}
      }
    },
    {{/each}}
  ]

  Config.fromPublic(
    %raw(`internalConfigJson`),
    ~codegenChains,
    ~userEntities=Entities.userEntities,
    ~registeredHandlers,
  )
}

// Config without handler registration - used by tests, migrations, etc.
let configWithoutRegistrations = makeGeneratedConfig()

// Config with registered handlers - call after handler registration
let makeConfigWithHandlers = () => makeGeneratedConfig(~registeredHandlers=collectRegisteredHandlers())

let initialSql = PgStorage.makeClient()
let storagePgSchema = Env.Db.publicSchema
let makeStorage = (~sql, ~pgSchema=storagePgSchema, ~isHasuraEnabled=Env.Hasura.enabled) => {
  PgStorage.make(
    ~sql,
    ~pgSchema,
    ~pgHost=Env.Db.host,
    ~pgUser=Env.Db.user,
    ~pgPort=Env.Db.port,
    ~pgDatabase=Env.Db.database,
    ~pgPassword=Env.Db.password,
    ~sink=?{
      switch Env.ClickHouseSink.host {
      | Some(host) => Some(Sink.makeClickHouse(~host, ~database=Env.ClickHouseSink.database, ~username=Env.ClickHouseSink.username, ~password=Env.ClickHouseSink.password))
      | None => None
      }
    },
    ~onInitialize=?{
      if isHasuraEnabled {
        Some(
          () => {
            Hasura.trackDatabase(
              ~endpoint=Env.Hasura.graphqlEndpoint,
              ~auth={
                role: Env.Hasura.role,
                secret: Env.Hasura.secret,
              },
              ~pgSchema=storagePgSchema,
              ~userEntities=Entities.userEntities,
              ~responseLimit=Env.Hasura.responseLimit,
              ~schema=Db.schema,
              ~aggregateEntities=Env.Hasura.aggregateEntities,
            )->Promise.catch(err => {
              Logging.errorWithExn(
                err->Utils.prettifyExn,
                `EE803: Error tracking tables`,
              )->Promise.resolve
            })
          },
        )
      } else {
        None
      }
    },
    ~onNewTables=?{
      if isHasuraEnabled {
        Some(
          (~tableNames) => {
            Hasura.trackTables(
              ~endpoint=Env.Hasura.graphqlEndpoint,
              ~auth={
                role: Env.Hasura.role,
                secret: Env.Hasura.secret,
              },
              ~pgSchema=storagePgSchema,
              ~tableNames,
            )->Promise.catch(err => {
              Logging.errorWithExn(
                err->Utils.prettifyExn,
                `EE804: Error tracking new tables`,
              )->Promise.resolve
            })
          },
        )
      } else {
        None
      }
    },
    ~isHasuraEnabled,
  )
}

let codegenPersistence = Persistence.make(
  ~userEntities=Entities.userEntities,
  ~allEnums=Enums.allEnums,
  ~storage=makeStorage(~sql=initialSql),
)
