@val external require: string => unit = "require"

let registerContractHandlers = (~contractName, ~handler: option<string>) => {
  switch handler {
  | None => ()
  | Some(handlerPath) =>
    try {
      require(handlerPath)
    } catch {
    | exn =>
      let params = {
        "Contract Name": contractName,
        "Expected Handler Path": handlerPath,
        "Code": "EE500",
      }
      let logger = Logging.createChild(~params)

      let errHandler = exn->ErrorHandling.make(~msg="Failed to import handler file", ~logger)
      errHandler->ErrorHandling.log
      errHandler->ErrorHandling.raiseExn
    }
  }
}

@module("node:fs/promises") external globIterator: string => promise<'asyncIterator> = "glob"

let autoLoadHandlersFromSrc = async () => {
  let srcPattern = `${Path.relativePathToRootFromGenerated}/src/**/*.{js,ts}`
  let handlerFiles = try {
    // Relatvie to cwd (generated dir)
    let iterator = await globIterator(srcPattern)
    await iterator->Utils.Array.fromAsyncIterator
  } catch {
  | exn =>
    Js.Exn.raiseError(
      `Failed to glob src directory for auto-loading handlers. Pattern: ${srcPattern} (relative to generated dir). Errorerror: ${exn
          ->Utils.prettifyExn
          ->Obj.magic}`,
    )
  }

  handlerFiles->Js.Array2.forEach(file => {
    try {
      // Since srcPattern is relative to generated dir,
      // and we require relative to the module (Generated.res)
      // We need to prepend additional "../" to the file path
      %raw(`require("../" + file)`)
    } catch {
    | exn =>
      Js.Exn.raiseError(
        `Failed to auto-load handler file: ${file} with error: ${exn
          ->Utils.prettifyExn
          ->Obj.magic}`,
      )
    }
  })
}

let makeGeneratedConfig = () => {
  let chains = [
    {{#each chain_configs as | chain_config |}}
    {
      let contracts = [
        {{#each chain_config.codegen_contracts as | contract |}}
        {
          Config.name: "{{contract.name.capitalized}}",
          abi: Types.{{contract.name.capitalized}}.abi,
          addresses: [
            {{#each contract.addresses as | address |}}
            {{#if ../../../is_evm_ecosystem}}
            {{#if ../../../lowercase_addresses}}
            "{{address}}"->Address.Evm.fromStringLowercaseOrThrow
            {{else}}
            "{{address}}"->Address.Evm.fromStringOrThrow
            {{/if}}
            {{else}}
            "{{address}}"->Address.unsafeFromString
            {{/if}},
            {{/each}}
          ],
          events: [
            {{#each contract.events as | event |}}
            (Types.{{contract.name.capitalized}}.{{event.name}}.register() :> Internal.eventConfig),
            {{/each}}
          ],
          startBlock: {{#if contract.start_block}}Some({{contract.start_block}}){{else}}None{{/if}},
        },
        {{/each}}
      ]
      let chain = ChainMap.Chain.makeUnsafe(~chainId={{chain_config.network_config.id}})
      {
        Config.maxReorgDepth: {{chain_config.network_config.confirmed_block_threshold}},
        startBlock: {{chain_config.network_config.start_block}},
        {{#if chain_config.network_config.end_block}}
        endBlock: {{chain_config.network_config.end_block}},
        {{/if}}
        id: {{chain_config.network_config.id}},
        contracts,
        sources: {{chain_config.sources_code}}
      }
    },
    {{/each}}
  ]

  Config.make(
    ~shouldRollbackOnReorg={{should_rollback_on_reorg}},
    ~shouldSaveFullHistory={{should_save_full_history}},
    ~multichain=if (
      Env.Configurable.isUnorderedMultichainMode->Belt.Option.getWithDefault(
        Env.Configurable.unstable__temp_unordered_head_mode->Belt.Option.getWithDefault(
          {{is_unordered_multichain_mode}},
        ),
      )
    ) {
      Unordered
    } else {
      Ordered
    },
    ~chains,
    ~enableRawEvents={{enable_raw_events}},
    ~batchSize=?Env.batchSize,
    ~preloadHandlers={{preload_handlers}},
    ~lowercaseAddresses={{lowercase_addresses}},
    ~shouldUseHypersyncClientDecoder={{should_use_hypersync_client_decoder}},
    {{#if chain_config.is_fuel}}
    ~ecosystem=Fuel,
    {{/if}}
  )
}

let configWithoutRegistrations = makeGeneratedConfig()

let registerAllHandlers = async () => {
  EventRegister.startRegistration(
    ~ecosystem=configWithoutRegistrations.ecosystem,
    ~multichain=configWithoutRegistrations.multichain,
    ~preloadHandlers=configWithoutRegistrations.preloadHandlers,
  )

  // Auto-load all .js files from src directory
  await autoLoadHandlersFromSrc()

  // Load contract-specific handlers (existing behavior)
  {{#each codegen_contracts as |contract|}}
  registerContractHandlers(
    ~contractName="{{contract.name.capitalized}}",
    ~handler={{#if contract.handler}}Some(`../${Path.relativePathToRootFromGenerated}/{{contract.handler}}`){{else}}None{{/if}},
  )
  {{/each}}

  EventRegister.finishRegistration()
}

let initialSql = Db.makeClient()
let storagePgSchema = Env.Db.publicSchema
let makeStorage = (~sql, ~pgSchema=storagePgSchema, ~isHasuraEnabled=Env.Hasura.enabled) => {
  PgStorage.make(
    ~sql,
    ~pgSchema,
    ~pgHost=Env.Db.host,
    ~pgUser=Env.Db.user,
    ~pgPort=Env.Db.port,
    ~pgDatabase=Env.Db.database,
    ~pgPassword=Env.Db.password,
    ~onInitialize=?{
      if isHasuraEnabled {
        Some(
          () => {
            Hasura.trackDatabase(
              ~endpoint=Env.Hasura.graphqlEndpoint,
              ~auth={
                role: Env.Hasura.role,
                secret: Env.Hasura.secret,
              },
              ~pgSchema=storagePgSchema,
              ~userEntities=Entities.userEntities,
              ~responseLimit=Env.Hasura.responseLimit,
              ~schema=Db.schema,
              ~aggregateEntities=Env.Hasura.aggregateEntities,
            )->Promise.catch(err => {
              Logging.errorWithExn(
                err->Utils.prettifyExn,
                `EE803: Error tracking tables`,
              )->Promise.resolve
            })
          },
        )
      } else {
        None
      }
    },
    ~onNewTables=?{
      if isHasuraEnabled {
        Some(
          (~tableNames) => {
            Hasura.trackTables(
              ~endpoint=Env.Hasura.graphqlEndpoint,
              ~auth={
                role: Env.Hasura.role,
                secret: Env.Hasura.secret,
              },
              ~pgSchema=storagePgSchema,
              ~tableNames,
            )->Promise.catch(err => {
              Logging.errorWithExn(
                err->Utils.prettifyExn,
                `EE804: Error tracking new tables`,
              )->Promise.resolve
            })
          },
        )
      } else {
        None
      }
    },
    ~isHasuraEnabled,
  )
}

let codegenPersistence = Persistence.make(
  ~userEntities=Entities.userEntities,
  ~allEnums=Enums.allEnums,
  ~storage=makeStorage(~sql=initialSql),
  ~sql=initialSql,
)

%%private(let indexer: ref<option<Indexer.t>> = ref(None))
let getIndexer = async () => {
  switch indexer.contents {
  | Some(indexer) => indexer
  | None =>
    let registrations = await registerAllHandlers()
    let i = {
      Indexer.registrations: registrations,
      // Need to recreate initial config one more time,
      // since configWithoutRegistrations called register for event
      // before they were ready
      config: makeGeneratedConfig(),
      persistence: codegenPersistence,
    }
    indexer := Some(i)
    i
  }
}
