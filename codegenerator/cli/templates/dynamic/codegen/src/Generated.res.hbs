@module("../internal.config.ts")
external internalConfigJson: Js.Json.t = "default"

let registerContractHandlers = async (~contractName, ~handler: option<string>) => {
  switch handler {
  | None => ()
  | Some(handlerPath) =>
    try {
      let _ = await Utils.importPath(handlerPath)
    } catch {
    | exn =>
      Logging.errorWithExn(exn, `Failed to load handler file for contract ${contractName}: ${handlerPath}`)
      Js.Exn.raiseError(
        `Failed to load handler file for contract ${contractName}: ${handlerPath}`,
      )
    }
  }
}

@module("node:fs/promises") external globIterator: string => promise<Utils.asyncIterator<string>> = "glob"

let autoLoadFromSrcHandlers = async () => {
  // Relative to cwd (project root)
  let srcPattern = `./{{#if handlers_path}}{{handlers_path}}{{else}}src/handlers{{/if}}/**/*.{js,mjs,ts}`
  let handlerFiles = try {
    let iterator = await globIterator(srcPattern)
    await iterator->Utils.Array.fromAsyncIterator
  } catch {
  | exn =>
    Js.Exn.raiseError(
      `Failed to glob src/handlers directory for auto-loading handlers. Pattern: ${srcPattern}. Before continuing, check that you're using Node.js >=22 version. Error: ${exn
          ->Utils.prettifyExn
          ->Obj.magic}`,
    )
  }

  // Since srcPattern is relative to project root,
  // and we import relative to the module (Generated.res)
  // We need to prepend additional "../" and {{relative_path_to_root_from_generated}} to the file path
  let _ = await handlerFiles
    ->Js.Array2.map(file => {
      Utils.importPath("../{{relative_path_to_root_from_generated}}/" ++ file)
      ->Promise.catch(exn => {
        Logging.errorWithExn(exn, `Failed to auto-load handler file: ${file}`)
        Js.Exn.raiseError(
          `Failed to auto-load handler file: ${file}`,
        )
      })
    })
    ->Promise.all
}

let makeGeneratedConfig = () => {
  let codegenChains = [
    {{#each chain_configs as | chain_config |}}
    {
      let contracts = [
        {{#each chain_config.codegen_contracts as | contract |}}
        {
          Config.name: "{{contract.name.capitalized}}",
          abi: Types.{{contract.name.capitalized}}.abi,
          addresses: [
            {{#each contract.addresses as | address |}}
            {{#if ../../../is_evm_ecosystem}}
            {{#if ../../../lowercase_addresses}}
            "{{address}}"->Address.Evm.fromStringLowercaseOrThrow
            {{else}}
            "{{address}}"->Address.Evm.fromStringOrThrow
            {{/if}}
            {{else}}
            "{{address}}"->Address.unsafeFromString
            {{/if}},
            {{/each}}
          ],
          events: [
            {{#each contract.events as | event |}}
            (Types.{{contract.name.capitalized}}.{{event.name}}.register() :> Internal.eventConfig),
            {{/each}}
          ],
          startBlock: {{#if contract.start_block}}Some({{contract.start_block}}){{else}}None{{/if}},
        },
        {{/each}}
      ]
      let chain = ChainMap.Chain.makeUnsafe(~chainId={{chain_config.network_config.id}})
      {
        Config.maxReorgDepth: {{chain_config.network_config.max_reorg_depth}},
        startBlock: {{chain_config.network_config.start_block}},
        {{#if chain_config.network_config.end_block}}
        endBlock: {{chain_config.network_config.end_block}},
        {{/if}}
        id: {{chain_config.network_config.id}},
        contracts,
        sources: {{chain_config.sources_code}}
      }
    },
    {{/each}}
  ]

  Config.fromPublic(
    internalConfigJson,
    ~shouldRollbackOnReorg={{should_rollback_on_reorg}},
    ~shouldSaveFullHistory={{should_save_full_history}},
    ~multichain=if {{is_unordered_multichain_mode}} {
      Unordered
    } else {
      Ordered
    },
    ~codegenChains,
    ~enableRawEvents={{enable_raw_events}},
    ~batchSize=?{{full_batch_size_code}},
    ~lowercaseAddresses={{lowercase_addresses}},
    ~shouldUseHypersyncClientDecoder={{should_use_hypersync_client_decoder}},
    {{#if is_fuel_ecosystem}}
    ~ecosystem=Fuel,
    {{/if}}
    {{#if is_svm_ecosystem}}
    ~ecosystem=Svm,
    {{/if}}
    ~userEntities=Entities.userEntities,
  )
}

let configWithoutRegistrations = makeGeneratedConfig()

let registerAllHandlers = async () => {
  EventRegister.startRegistration(
    ~ecosystem=configWithoutRegistrations.ecosystem,
    ~multichain=configWithoutRegistrations.multichain,
  )

  // Auto-load all .js files from src/handlers directory
  await autoLoadFromSrcHandlers()

  // Load contract-specific handlers (existing behavior)
  let _ = await [
    {{#each codegen_contracts as |contract|}}
    registerContractHandlers(
      ~contractName="{{contract.name.capitalized}}",
      ~handler={{#if contract.handler}}Some(`../${Path.relativePathToRootFromGenerated}/{{contract.handler}}`){{else}}None{{/if}},
    ),
    {{/each}}
  ]->Promise.all

  EventRegister.finishRegistration()
}

let initialSql = PgStorage.makeClient()
let storagePgSchema = Env.Db.publicSchema
let makeStorage = (~sql, ~pgSchema=storagePgSchema, ~isHasuraEnabled=Env.Hasura.enabled) => {
  PgStorage.make(
    ~sql,
    ~pgSchema,
    ~pgHost=Env.Db.host,
    ~pgUser=Env.Db.user,
    ~pgPort=Env.Db.port,
    ~pgDatabase=Env.Db.database,
    ~pgPassword=Env.Db.password,
    ~sink=?{
      switch Env.ClickHouseSink.host {
      | Some(host) => Some(Sink.makeClickHouse(~host, ~database=Env.ClickHouseSink.database, ~username=Env.ClickHouseSink.username, ~password=Env.ClickHouseSink.password))
      | None => None
      }
    },
    ~onInitialize=?{
      if isHasuraEnabled {
        Some(
          () => {
            Hasura.trackDatabase(
              ~endpoint=Env.Hasura.graphqlEndpoint,
              ~auth={
                role: Env.Hasura.role,
                secret: Env.Hasura.secret,
              },
              ~pgSchema=storagePgSchema,
              ~userEntities=Entities.userEntities,
              ~responseLimit=Env.Hasura.responseLimit,
              ~schema=Db.schema,
              ~aggregateEntities=Env.Hasura.aggregateEntities,
            )->Promise.catch(err => {
              Logging.errorWithExn(
                err->Utils.prettifyExn,
                `EE803: Error tracking tables`,
              )->Promise.resolve
            })
          },
        )
      } else {
        None
      }
    },
    ~onNewTables=?{
      if isHasuraEnabled {
        Some(
          (~tableNames) => {
            Hasura.trackTables(
              ~endpoint=Env.Hasura.graphqlEndpoint,
              ~auth={
                role: Env.Hasura.role,
                secret: Env.Hasura.secret,
              },
              ~pgSchema=storagePgSchema,
              ~tableNames,
            )->Promise.catch(err => {
              Logging.errorWithExn(
                err->Utils.prettifyExn,
                `EE804: Error tracking new tables`,
              )->Promise.resolve
            })
          },
        )
      } else {
        None
      }
    },
    ~isHasuraEnabled,
  )
}

let codegenPersistence = Persistence.make(
  ~userEntities=Entities.userEntities,
  ~allEnums=Enums.allEnums,
  ~storage=makeStorage(~sql=initialSql),
)
