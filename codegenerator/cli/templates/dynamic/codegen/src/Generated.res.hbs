@val external require: string => unit = "require"

let registerContractHandlers = (
  ~contractName,
  ~handlerPathRelativeToRoot,
  ~handlerPathRelativeToConfig,
) => {
  try {
    require(`../${Path.relativePathToRootFromGenerated}/${handlerPathRelativeToRoot}`)
  } catch {
  | exn =>
    let params = {
      "Contract Name": contractName,
      "Expected Handler Path": handlerPathRelativeToConfig,
      "Code": "EE500",
    }
    let logger = Logging.createChild(~params)

    let errHandler = exn->ErrorHandling.make(~msg="Failed to import handler file", ~logger)
    errHandler->ErrorHandling.log
    errHandler->ErrorHandling.raiseExn
  }
}

let makeGeneratedConfig = () => {
  let chains = [
    {{#each chain_configs as | chain_config |}}
    {
      let contracts = [
        {{#each chain_config.codegen_contracts as | contract |}}
        {
          Config.name: "{{contract.name.capitalized}}",
          abi: Types.{{contract.name.capitalized}}.abi,
          addresses: [
            {{#each contract.addresses as | address |}}
            {{#if ../../../is_evm_ecosystem}}
            {{#if ../../../lowercase_addresses}}
            "{{address}}"->Address.Evm.fromStringLowercaseOrThrow
            {{else}}
            "{{address}}"->Address.Evm.fromStringOrThrow
            {{/if}}
            {{else}}
            "{{address}}"->Address.unsafeFromString
            {{/if}},
            {{/each}}
          ],
          events: [
            {{#each contract.events as | event |}}
            (Types.{{contract.name.capitalized}}.{{event.name}}.register() :> Internal.eventConfig),
            {{/each}}
          ],
          startBlock: {{#if contract.start_block}}Some({{contract.start_block}}){{else}}None{{/if}},
        },
        {{/each}}
      ]
      let chain = ChainMap.Chain.makeUnsafe(~chainId={{chain_config.network_config.id}})
      {
        Config.maxReorgDepth: {{chain_config.network_config.confirmed_block_threshold}},
        startBlock: {{chain_config.network_config.start_block}},
        {{#if chain_config.network_config.end_block}}
        endBlock: {{chain_config.network_config.end_block}},
        {{/if}}
        id: {{chain_config.network_config.id}},
        contracts,
        sources: {{chain_config.sources_code}}
      }
    },
    {{/each}}
  ]

  Config.make(
    ~shouldRollbackOnReorg={{should_rollback_on_reorg}},
    ~shouldSaveFullHistory={{should_save_full_history}},
    ~multichain=if (
      Env.Configurable.isUnorderedMultichainMode->Belt.Option.getWithDefault(
        Env.Configurable.unstable__temp_unordered_head_mode->Belt.Option.getWithDefault(
          {{is_unordered_multichain_mode}},
        ),
      )
    ) {
      Unordered
    } else {
      Ordered
    },
    ~chains,
    ~enableRawEvents={{enable_raw_events}},
    ~batchSize=?Env.batchSize,
    ~preloadHandlers={{preload_handlers}},
    ~lowercaseAddresses={{lowercase_addresses}},
    ~shouldUseHypersyncClientDecoder={{should_use_hypersync_client_decoder}},
    {{#if chain_config.is_fuel}}
    ~ecosystem=Fuel,
    {{/if}}
  )
}

let configWithoutRegistrations = makeGeneratedConfig()

let registerAllHandlers = () => {
  EventRegister.startRegistration(
    ~ecosystem=configWithoutRegistrations.ecosystem,
    ~multichain=configWithoutRegistrations.multichain,
    ~preloadHandlers=configWithoutRegistrations.preloadHandlers,
  )

  {{#each codegen_contracts as |contract|}}
  registerContractHandlers(
    ~contractName="{{contract.name.capitalized}}",
    ~handlerPathRelativeToRoot="{{contract.handler.relative_to_project_root}}",
    ~handlerPathRelativeToConfig="{{contract.handler.relative_to_config}}",
  )
  {{/each}}

  EventRegister.finishRegistration()
}

let initialSql = Db.makeClient()
let storagePgSchema = Env.Db.publicSchema
let makeStorage = (~sql, ~pgSchema=storagePgSchema, ~isHasuraEnabled=Env.Hasura.enabled) => {
  PgStorage.make(
    ~sql,
    ~pgSchema,
    ~pgHost=Env.Db.host,
    ~pgUser=Env.Db.user,
    ~pgPort=Env.Db.port,
    ~pgDatabase=Env.Db.database,
    ~pgPassword=Env.Db.password,
    ~onInitialize=?{
      if isHasuraEnabled {
        Some(
          () => {
            Hasura.trackDatabase(
              ~endpoint=Env.Hasura.graphqlEndpoint,
              ~auth={
                role: Env.Hasura.role,
                secret: Env.Hasura.secret,
              },
              ~pgSchema=storagePgSchema,
              ~userEntities=Entities.userEntities,
              ~responseLimit=Env.Hasura.responseLimit,
              ~schema=Db.schema,
              ~aggregateEntities=Env.Hasura.aggregateEntities,
            )->Promise.catch(err => {
              Logging.errorWithExn(
                err->Utils.prettifyExn,
                `EE803: Error tracking tables`,
              )->Promise.resolve
            })
          },
        )
      } else {
        None
      }
    },
    ~onNewTables=?{
      if isHasuraEnabled {
        Some(
          (~tableNames) => {
            Hasura.trackTables(
              ~endpoint=Env.Hasura.graphqlEndpoint,
              ~auth={
                role: Env.Hasura.role,
                secret: Env.Hasura.secret,
              },
              ~pgSchema=storagePgSchema,
              ~tableNames,
            )->Promise.catch(err => {
              Logging.errorWithExn(
                err->Utils.prettifyExn,
                `EE804: Error tracking new tables`,
              )->Promise.resolve
            })
          },
        )
      } else {
        None
      }
    },
    ~isHasuraEnabled,
  )
}

let codegenPersistence = Persistence.make(
  ~userEntities=Entities.userEntities,
  ~allEnums=Enums.allEnums,
  ~storage=makeStorage(~sql=initialSql),
  ~sql=initialSql,
)

%%private(let indexer: ref<option<Indexer.t>> = ref(None))
let getIndexer = () => {
  switch indexer.contents {
  | Some(indexer) => indexer
  | None =>
    let i = {
      Indexer.registrations: registerAllHandlers(),
      // Need to recreate initial config one more time,
      // since configWithoutRegistrations called register for event
      // before they were ready
      config: makeGeneratedConfig(),
      persistence: codegenPersistence,
    }
    indexer := Some(i)
    i
  }
}
