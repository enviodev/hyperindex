@@directive("import internalConfigJson from '../internal.config.json' with { type: 'json' }")

// Handler loading params - extracted from config without building full config
// These are used to load handlers BEFORE creating the full config
let handlerLoadingParams = Config.getHandlerLoadingParams(%raw(`internalConfigJson`))

let makeGeneratedConfig = () => {
  let codegenChains = [
    {{#each chain_configs as | chain_config |}}
    {
      let contracts = [
        {{#each chain_config.codegen_contracts as | contract |}}
        {
          Config.name: "{{contract.name.capitalized}}",
          addresses: [
            {{#each contract.addresses as | address |}}
            "{{address}}",
            {{/each}}
          ],
          events: [
            {{#each contract.events as | event |}}
            (Types.{{contract.name.capitalized}}.{{event.name}}.register() :> Internal.eventConfig),
            {{/each}}
          ],
          startBlock: {{#if contract.start_block}}Some({{contract.start_block}}){{else}}None{{/if}},
        },
        {{/each}}
      ]
      let chain = ChainMap.Chain.makeUnsafe(~chainId={{chain_config.network_config.id}})
      {
        Config.id: {{chain_config.network_config.id}},
        contracts,
        sources: {{chain_config.sources_code}}
      }
    },
    {{/each}}
  ]

  Config.fromPublic(
    %raw(`internalConfigJson`),
    ~codegenChains,
    ~userEntities=Entities.userEntities,
  )
}

// Config without handler registration - used by tests, migrations, etc.
let configWithoutRegistrations = makeGeneratedConfig()

// Register all handlers and return the config with registrations
// Must be called BEFORE using the config for indexing
let registerAllHandlers = async () => {
  await HandlerLoader.registerAllHandlers(
    ~ecosystem=handlerLoadingParams.ecosystem,
    ~multichain=handlerLoadingParams.multichain,
    ~handlers=handlerLoadingParams.handlers,
    ~contractHandlers=handlerLoadingParams.contractHandlers,
  )
  // Return fresh config after handlers are registered
  makeGeneratedConfig()
}

let initialSql = PgStorage.makeClient()
let storagePgSchema = Env.Db.publicSchema
let makeStorage = (~sql, ~pgSchema=storagePgSchema, ~isHasuraEnabled=Env.Hasura.enabled) => {
  PgStorage.make(
    ~sql,
    ~pgSchema,
    ~pgHost=Env.Db.host,
    ~pgUser=Env.Db.user,
    ~pgPort=Env.Db.port,
    ~pgDatabase=Env.Db.database,
    ~pgPassword=Env.Db.password,
    ~sink=?{
      switch Env.ClickHouseSink.host {
      | Some(host) => Some(Sink.makeClickHouse(~host, ~database=Env.ClickHouseSink.database, ~username=Env.ClickHouseSink.username, ~password=Env.ClickHouseSink.password))
      | None => None
      }
    },
    ~onInitialize=?{
      if isHasuraEnabled {
        Some(
          () => {
            Hasura.trackDatabase(
              ~endpoint=Env.Hasura.graphqlEndpoint,
              ~auth={
                role: Env.Hasura.role,
                secret: Env.Hasura.secret,
              },
              ~pgSchema=storagePgSchema,
              ~userEntities=Entities.userEntities,
              ~responseLimit=Env.Hasura.responseLimit,
              ~schema=Db.schema,
              ~aggregateEntities=Env.Hasura.aggregateEntities,
            )->Promise.catch(err => {
              Logging.errorWithExn(
                err->Utils.prettifyExn,
                `EE803: Error tracking tables`,
              )->Promise.resolve
            })
          },
        )
      } else {
        None
      }
    },
    ~onNewTables=?{
      if isHasuraEnabled {
        Some(
          (~tableNames) => {
            Hasura.trackTables(
              ~endpoint=Env.Hasura.graphqlEndpoint,
              ~auth={
                role: Env.Hasura.role,
                secret: Env.Hasura.secret,
              },
              ~pgSchema=storagePgSchema,
              ~tableNames,
            )->Promise.catch(err => {
              Logging.errorWithExn(
                err->Utils.prettifyExn,
                `EE804: Error tracking new tables`,
              )->Promise.resolve
            })
          },
        )
      } else {
        None
      }
    },
    ~isHasuraEnabled,
  )
}

let codegenPersistence = Persistence.make(
  ~userEntities=Entities.userEntities,
  ~allEnums=Enums.allEnums,
  ~storage=makeStorage(~sql=initialSql),
)
