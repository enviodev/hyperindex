@val external require: string => unit = "require"

let registerContractHandlers = (
  ~contractName,
  ~handlerPathRelativeToRoot,
  ~handlerPathRelativeToConfig,
) => {
  try {
    require("handlers/" ++ handlerPathRelativeToRoot)
  } catch {
  | exn =>
    let params = {
      "Contract Name": contractName,
      "Expected Handler Path": handlerPathRelativeToConfig,
      "Code": "EE500",
    }
    let logger = Logging.createChild(~params)

    let errHandler = exn->ErrorHandling.make(~msg="Failed to import handler file", ~logger)
    errHandler->ErrorHandling.log
    errHandler->ErrorHandling.raiseExn
  }
}

// TODO: Start using only config returned by registerAllHandlers instead of Config.getGenerated and Config.setGenerated
%%private(
  let chains = [
    {{#each chain_configs as | chain_config |}}
    {
      Config.confirmedBlockThreshold: {{chain_config.network_config.confirmed_block_threshold}},
      syncSource: 
        {{#if chain_config.network_config.rpc_config}}
        Rpc({
          provider: Ethers.JsonRpcProvider.make(
            ~rpcUrls={{vec_to_array chain_config.network_config.rpc_config.urls}},
            ~chainId={{chain_config.network_config.id}}
          ),
        {{#with chain_config.network_config.rpc_config.sync_config as | sync_config |}}
          syncConfig: Config.getSyncConfig({
            initialBlockInterval: {{sync_config.initial_block_interval}},
            backoffMultiplicative: {{sync_config.backoff_multiplicative}},
            accelerationAdditive: {{sync_config.acceleration_additive}},
            intervalCeiling: {{sync_config.interval_ceiling}},
            backoffMillis: {{sync_config.backoff_millis}},
            queryTimeoutMillis: {{sync_config.query_timeout_millis}},
          }),
        }),
        {{/with}}
        {{/if}}
        {{#if chain_config.network_config.skar_server_url}}
        HyperSync({endpointUrl: "{{chain_config.network_config.skar_server_url}}"}),
        {{/if}}
      startBlock: {{chain_config.network_config.start_block}},
      endBlock: {{#if chain_config.network_config.end_block}} Some({{chain_config.network_config.end_block}}) {{else}} None {{/if}},
      chain: ChainMap.Chain.makeUnsafe(~chainId={{chain_config.network_config.id}}),
      contracts: [
      {{#each chain_config.codegen_contracts as | contract |}}
        {
          name: "{{contract.name.capitalized}}",
          abi: Abis.{{contract.name.uncapitalized}}Abi->Ethers.makeAbi,
          addresses: [
            {{#each contract.addresses as | address |}}
            "{{address}}"->Ethers.getAddressFromStringUnsafe,
            {{/each}}
          ],
          events: [
            {{#each contract.events as | event |}}
            module(Types.{{contract.name.capitalized}}.{{event.name.capitalized}}),
            {{/each}}
          ],
        },
      {{/each}}
      ],
    },
    {{/each}}
  ]

  let config = Config.make(
    ~shouldRollbackOnReorg={{should_rollback_on_reorg}},
    ~shouldSaveFullHistory={{should_save_full_history}},
    ~shouldUseHypersyncClientDecoder={{should_use_hypersync_client_decoder}},
    ~isUnorderedMultichainMode={{is_unordered_multichain_mode}},
    ~chains,
  )
  Config.setGenerated(config)
)

let registerAllHandlers = () => {
{{#each codegen_contracts as |contract|}}
  registerContractHandlers(
    ~contractName="{{contract.name.capitalized}}",
    ~handlerPathRelativeToRoot="{{contract.handler.relative_to_project_root}}",
    ~handlerPathRelativeToConfig="{{contract.handler.relative_to_config}}",
  )
{{/each}}
  config
}
