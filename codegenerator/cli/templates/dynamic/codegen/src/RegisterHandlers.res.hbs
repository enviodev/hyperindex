@val external require: string => unit = "require"

let registerContractHandlers = (
  ~contractName,
  ~handlerPathRelativeToRoot,
  ~handlerPathRelativeToConfig,
) => {
  try {
    require("root/" ++ handlerPathRelativeToRoot)
  } catch {
  | exn =>
    let params = {
      "Contract Name": contractName,
      "Expected Handler Path": handlerPathRelativeToConfig,
      "Code": "EE500",
    }
    let logger = Logging.createChild(~params)

    let errHandler = exn->ErrorHandling.make(~msg="Failed to import handler file", ~logger)
    errHandler->ErrorHandling.log
    errHandler->ErrorHandling.raiseExn
  }
}

// TODO: Start using only config returned by registerAllHandlers instead of Config.getGenerated and Config.setGenerated
%%private(
  let chains = [
    {{#each chain_configs as | chain_config |}}
    {
      let contracts = [
        {{#each chain_config.codegen_contracts as | contract |}}
        {
          Config.name: "{{contract.name.capitalized}}",
          abi: Abis.{{contract.name.uncapitalized}}Abi->Ethers.makeAbi,
          addresses: [
            {{#each contract.addresses as | address |}}
            "{{address}}"->Ethers.getAddressFromStringUnsafe,
            {{/each}}
          ],
          events: [
            {{#each contract.events as | event |}}
            module(Types.{{contract.name.capitalized}}.{{event.name.capitalized}}),
            {{/each}}
          ],
        },
        {{/each}}
      ]
      let chain = ChainMap.Chain.makeUnsafe(~chainId={{chain_config.network_config.id}})
      {
        Config.confirmedBlockThreshold: {{chain_config.network_config.confirmed_block_threshold}},
        syncSource: 
          {{#if chain_config.network_config.rpc_config}}
          Rpc({
            provider: Ethers.JsonRpcProvider.make(
              ~rpcUrls={{vec_to_array chain_config.network_config.rpc_config.urls}},
              ~chainId={{chain_config.network_config.id}},
              ~fallbackStallTimeout={{chain_config.network_config.rpc_config.sync_config.fallback_stall_timeout}},
            ),
          {{#with chain_config.network_config.rpc_config.sync_config as | sync_config |}}
            syncConfig: Config.getSyncConfig({
              initialBlockInterval: {{sync_config.initial_block_interval}},
              backoffMultiplicative: {{sync_config.backoff_multiplicative}},
              accelerationAdditive: {{sync_config.acceleration_additive}},
              intervalCeiling: {{sync_config.interval_ceiling}},
              backoffMillis: {{sync_config.backoff_millis}},
              queryTimeoutMillis: {{sync_config.query_timeout_millis}},
            }),
          }),
          {{/with}}
          {{/if}}
          {{#if chain_config.network_config.skar_server_url}}
          HyperSync({endpointUrl: "{{chain_config.network_config.skar_server_url}}"}),
          {{/if}}
        startBlock: {{chain_config.network_config.start_block}},
        endBlock: {{#if chain_config.network_config.end_block}} Some({{chain_config.network_config.end_block}}) {{else}} None {{/if}},
        chain,
        contracts,
        chainWorker:
          {{#if chain_config.network_config.rpc_config }}
          module(RpcWorker.Make({
            let chain = chain
            let contracts = contracts
            let rpcConfig: Config.rpcConfig = {
              provider: Ethers.JsonRpcProvider.make(
                ~rpcUrls={{vec_to_array chain_config.network_config.rpc_config.urls}},
                ~chainId={{chain_config.network_config.id}},
                ~fallbackStallTimeout={{chain_config.network_config.rpc_config.sync_config.fallback_stall_timeout}},
              ),
              {{#with chain_config.network_config.rpc_config.sync_config as | sync_config |}}
              syncConfig: Config.getSyncConfig({
                initialBlockInterval: {{sync_config.initial_block_interval}},
                backoffMultiplicative: {{sync_config.backoff_multiplicative}},
                accelerationAdditive: {{sync_config.acceleration_additive}},
                intervalCeiling: {{sync_config.interval_ceiling}},
                backoffMillis: {{sync_config.backoff_millis}},
                queryTimeoutMillis: {{sync_config.query_timeout_millis}},
              }),
              {{/with}}
            }
          }))
          {{/if}}
          {{#if chain_config.network_config.skar_server_url }}
          module(HyperSyncWorker.Make({
            let chain = chain
            let contracts = contracts
            let endpointUrl = "{{chain_config.network_config.skar_server_url}}"
            let allEventSignatures = Abis.EventSignatures.all
            /*
              Determines whether to use HypersyncClient Decoder or Viem for parsing events
              Default is hypersync client decoder, configurable in config with:
              ```yaml
              event_decoder: "viem" || "hypersync-client"
              ```
            */
            let shouldUseHypersyncClientDecoder = Env.Configurable.shouldUseHypersyncClientDecoder->Belt.Option.getWithDefault(
              {{../should_use_hypersync_client_decoder}},
            )
          }))
          {{/if}}
      }
    },
    {{/each}}
  ]

  let config = Config.make(
    ~shouldRollbackOnReorg={{should_rollback_on_reorg}},
    ~shouldSaveFullHistory={{should_save_full_history}},
    ~isUnorderedMultichainMode={{is_unordered_multichain_mode}},
    ~chains,
    ~enableRawEvents={{enable_raw_events}},
    ~entities=[
    {{#each entities as |entity|}}
      module(Entities.{{entity.name.capitalized}}),
    {{/each}}
    ],
  )
  Config.setGenerated(config)
)

let registerAllHandlers = () => {
{{#each codegen_contracts as |contract|}}
  registerContractHandlers(
    ~contractName="{{contract.name.capitalized}}",
    ~handlerPathRelativeToRoot="{{contract.handler.relative_to_project_root}}",
    ~handlerPathRelativeToConfig="{{contract.handler.relative_to_config}}",
  )
{{/each}}
  config
}
