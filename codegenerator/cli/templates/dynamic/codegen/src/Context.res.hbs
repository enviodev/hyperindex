type entityGetters = {
{{#each entities as | entity |}}
 get{{entity.name.capitalized}}: Types.id => promise<array<Entities.{{entity.name.capitalized}}.t>>,
{{/each}}
}

@genType
type genericContextCreatorFunctions<'loaderContext, 'handlerContextSync, 'handlerContextAsync> = {
  logger: Pino.t,
  log: Logs.userLogger,
  getLoaderContext: unit => 'loaderContext,
  getHandlerContextSync: unit => 'handlerContextSync,
  getHandlerContextAsync: unit => 'handlerContextAsync,
  getEntitiesToLoad: unit => array<Types.entityRead>,
  getAddedDynamicContractRegistrations: unit => array<Types.dynamicContractRegistryEntity>,
}

type contextCreator<'eventArgs, 'loaderContext, 'handlerContext, 'handlerContextAsync> = (
  ~inMemoryStore: IO.InMemoryStore.t,
  ~chainId: int,
  ~event: Types.eventLog<'eventArgs>,
  ~logger: Pino.t,
  ~asyncGetters: entityGetters,
) => genericContextCreatorFunctions<'loaderContext, 'handlerContext, 'handlerContextAsync>

let getEventIdentifier = (event: Types.eventLog<'a>, ~chainId): Types.eventIdentifier => {
  chainId,
  blockTimestamp: event.blockTimestamp,
  blockNumber: event.blockNumber,
  logIndex: event.logIndex,
}

exception UnableToLoadNonNullableLinkedEntity(string)
exception LinkedEntityNotAvailableInSyncHandler(string)

{{#each codegen_contracts as | contract |}}

module {{contract.name.capitalized}}Contract = {
{{#each contract.codegen_events as | event |}}

  module {{event.name.capitalized}}Event = {
    type loaderContext = Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.loaderContext
    type handlerContext = Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.handlerContext
    type handlerContextAsync = Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.handlerContextAsync
    type context = genericContextCreatorFunctions<
      loaderContext,
      handlerContext,
      handlerContextAsync,
    >

    let contextCreator: contextCreator<
      Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs,
      loaderContext,
      handlerContext,
      handlerContextAsync,
    > = (~inMemoryStore, ~chainId, ~event, ~logger, ~asyncGetters) => {
      let eventIdentifier = event->getEventIdentifier(~chainId)
      // NOTE: we could optimise this code to onle create a logger if there was a log called.
      let logger = logger->Logging.createChildFrom(
        ~logger=_,
        ~params={
          "context": "{{contract.name.capitalized}}.{{event.name.capitalized}}",
          "chainId": chainId,
          "block": event.blockNumber,
          "logIndex": event.logIndex,
          "txHash": event.transactionHash,
        },
      )

      let contextLogger: Logs.userLogger = {
        info: (message: string) => logger->Logging.uinfo(message),
        debug: (message: string) => logger->Logging.udebug(message),
        warn: (message: string) => logger->Logging.uwarn(message),
        error: (message: string) => logger->Logging.uerror(message),
        errorWithExn: (exn: option<Js.Exn.t>, message: string) =>
          logger->Logging.uerrorWithExn(exn, message),
      }

      {{#each event.required_entities as | required_entity |}}
      {{#if required_entity.labels}}
      {{#each required_entity.labels as |label| }}
      let optIdOf_{{label}} = ref(None)
      {{/each}}
      {{/if}}
      {{#if required_entity.array_labels}}
        {{#each required_entity.array_labels as |array_label|}}
          let optIdArrayOf_{{array_label}} = ref(None)
        {{/each}}
      {{/if}}
      let optSetOfIds_{{required_entity.name.uncapitalized}}: Set.t<Types.id> = Set.make()
      {{/each}}

      let entitiesToLoad: array<Types.entityRead> = []

      let addedDynamicContractRegistrations: array<Types.dynamicContractRegistryEntity> = []

      //Loader context can be defined as a value and the getter can return that value
      @warning("-16")
      let loaderContext: loaderContext = {
        log: contextLogger,
        contractRegistration: {
        {{#each ../../codegen_contracts as |contract_inner| }}
          //TODO only add contracts we've registered for the event in the config
          add{{contract_inner.name.capitalized}}: (contractAddress: Ethers.ethAddress) => 
          {
            let eventId = EventUtils.packEventIndex(
              ~blockNumber=event.blockNumber,
              ~logIndex=event.logIndex,
            )
            let dynamicContractRegistration: Types.dynamicContractRegistryEntity = {
              chainId,
              eventId,
              blockTimestamp: event.blockTimestamp,
              contractAddress,
              contractType: "{{contract_inner.name.capitalized}}",
            }

            addedDynamicContractRegistrations->Js.Array2.push(dynamicContractRegistration)->ignore

            inMemoryStore.dynamicContractRegistry->IO.InMemoryStore.DynamicContractRegistry.set(
              ~key={chainId, contractAddress},
              ~entity=dynamicContractRegistration,
            )
          },
        {{/each}}
        },
      {{#each event.required_entities as | required_entity |}}
        {{required_entity.name.uncapitalized}}: {
      {{#if required_entity.labels}}
      {{#each required_entity.labels as |label| }}
          {{label}}Load: (id: Types.id{{#if required_entity.entity_fields_of_required_entity.filtered_not_derived_from.[0]}}, ~loaders={}{{/if}}) => {
            optIdOf_{{label}} := Some(id)

            let _ = Js.Array2.push(entitiesToLoad, Types.{{required_entity.name.capitalized}}Read(id{{#if required_entity.entity_fields_of_required_entity.filtered_not_derived_from.[0]}}, loaders{{/if}}))
          },
      {{/each}}
      {{/if}}
      {{#if required_entity.array_labels}}
      {{#each required_entity.array_labels as |array_label| }}
          {{array_label}}Load: (ids: array<Types.id>{{#if required_entity.entity_fields_of_required_entity.filtered_not_derived_from.[0]}}, ~loaders={}{{/if}}) => {
            optIdArrayOf_{{array_label}} := Some(ids)

            let _ =
              ids->Belt.Array.map(id => entitiesToLoad->Js.Array2.push(Types.{{required_entity.name.capitalized}}Read(id{{#if required_entity.entity_fields_of_required_entity.filtered_not_derived_from.[0]}}, loaders{{/if}})))
          },
      {{/each}}
      {{/if}}
      
          load: (id: Types.id{{#if required_entity.entity_fields_of_required_entity.filtered_not_derived_from.[0]}}, ~loaders={}{{/if}}) => 
          {
            let _ = optSetOfIds_{{required_entity.name.uncapitalized}}->Set.add(id)
            let _ = Js.Array2.push(entitiesToLoad, Types.{{required_entity.name.capitalized}}Read(id{{#if required_entity.entity_fields_of_required_entity.filtered_not_derived_from.[0]}}, loaders{{/if}}))
          },
        },
      {{/each}}
      }

      //handler context must be defined as a getter function so that it can construct the context
      //without stale values whenever it is used
      let getHandlerContextSync: unit => handlerContext = () => {
          {{#each ../../entities as | entity |}}
            {{#each event.required_entities as | required_entity |}}
              {{#if (eq entity.name.capitalized required_entity.name.capitalized)}}
                {{#if required_entity.labels}}
                  {{#each required_entity.labels as |label| }}
                  let {{label}}_{{required_entity.name.capitalized}} = switch optIdOf_{{label}}.contents {
                    | Some(id) => inMemoryStore.{{required_entity.name.uncapitalized}}->IO.InMemoryStore.{{required_entity.name.capitalized}}.get(id)
                    | None =>
                      Logging.warn(`The loader for "{{label}}" of entity type "{{required_entity.name.capitalized}}"" was not used please add it to your loader function or remove it from your config.yaml file to avoid unexpected behaviour. This is a runtime validation check.`)
                      None
                    }
                  {{/each}}
                {{/if}}
                {{#if required_entity.array_labels}}
                  {{#each required_entity.array_labels as |array_label| }}
                  let {{array_label}}_{{required_entity.name.capitalized}} = switch optIdArrayOf_{{array_label}}.contents {
                    | Some(ids) =>
                      ids->Belt.Array.map(id => inMemoryStore.{{required_entity.name.uncapitalized}}->IO.InMemoryStore.{{required_entity.name.capitalized}}.get(id))
                    | None =>
                      Logging.warn(`The array loader for "{{array_label}}" of entity type "{{required_entity.name.capitalized}}"" was not used please add it to your loader function or remove it from your config.yaml file to avoid unexpected behaviour. This is a runtime validation check.`)
                      []
                    }
                  {{/each}}
                {{/if}}
              {{/if}}
            {{/each}}
          {{/each}}
        {
          log: contextLogger,
          {{#each ../../entities as | entity |}}
            {{entity.name.uncapitalized}}: {
              set: entity => {inMemoryStore.{{entity.name.uncapitalized}}->IO.InMemoryStore.{{entity.name.capitalized}}.set(
                ~key=entity.id,
                ~entity=Set(entity)->Types.mkEntityUpdate(~eventIdentifier),
              )},

              deleteUnsafe: id => {
                inMemoryStore.{{entity.name.uncapitalized}}->IO.InMemoryStore.{{entity.name.capitalized}}.set(
                ~key=id,
                ~entity=Delete(id)->Types.mkEntityUpdate(~eventIdentifier),
              )
                },
              {{#each event.required_entities as | required_entity |}}
                {{#if (eq entity.name.capitalized required_entity.name.capitalized)}}
                  {{#if required_entity.labels}}
                  {{#each required_entity.labels as |label| }}
                  {{label}}: {{label}}_{{required_entity.name.capitalized}},
                  {{/each}}
                  {{/if}}
                  {{#if required_entity.array_labels}}
                  {{#each required_entity.array_labels as |array_label| }}
                  {{array_label}}: {{array_label}}_{{required_entity.name.capitalized}},
                  {{/each}}
                  {{/if}}
                  get: (id: Types.id) => {
                    if (optSetOfIds_{{required_entity.name.uncapitalized}}->Set.has(id)) {
                      inMemoryStore.{{required_entity.name.uncapitalized}}->IO.InMemoryStore.{{required_entity.name.capitalized}}.get(id)
                    } else {
                      Logging.warn(
                        `The loader for a "{{required_entity.name.capitalized}}" of entity with id "${id}" was not used please add it to your default loader function (ie. place 'context.{{required_entity.name.uncapitalized}}.load("${id}")' inside your loader) to avoid unexpected behaviour. This is a runtime validation check.`,
                      )

                      // NOTE: this will still return the value if it exists in the in-memory store (despite the loader not being run).
                      inMemoryStore.{{required_entity.name.uncapitalized}}->IO.InMemoryStore.{{required_entity.name.capitalized}}.get(id)

                      // TODO: add a further step to synchronously try fetch this from the DB if it isn't in the in-memory store - similar to this PR: https://github.com/Float-Capital/indexer/pull/759
                    }
                 },
                {{/if}}
              {{/each}}
              {{#each entity.relational_params.filtered_not_derived_from as | entity_field |}}
              get{{entity_field.relational_key.capitalized}}: {{entity.name.uncapitalized}} => {
                {{#if entity_field.is_optional}}
                 switch {{entity.name.uncapitalized}}.{{entity_field.relational_key.uncapitalized}}_id {
                  | Some({{entity_field.relational_key.uncapitalized}}_field) =>
                    // TODO: we aren't handling the case where the code is an optional array. Maybe we should enforce that at the compile step, and force users to use an empty array instead.
                    let opt{{entity_field.relational_key.capitalized}} = inMemoryStore.{{entity_field.mapped_entity.uncapitalized}}->IO.InMemoryStore.{{entity_field.mapped_entity.capitalized}}.get({{entity_field.relational_key.uncapitalized}}_field)

                    (
                {{else}}
                  let opt{{entity_field.relational_key.capitalized}} = inMemoryStore.{{entity_field.mapped_entity.uncapitalized}}->IO.InMemoryStore.{{entity_field.mapped_entity.capitalized}}.get({{entity.name.uncapitalized}}.{{entity_field.relational_key.uncapitalized}}_id)
                {{/if}}
                  switch opt{{entity_field.relational_key.capitalized}} {
                  | Some({{entity_field.relational_key.uncapitalized}}) => {{entity_field.relational_key.uncapitalized}}
                  | None =>
                    Logging.error(`Linked entity field '{{entity_field.relational_key.uncapitalized}}' not found  for '{{entity.name.capitalized}}' entity.
Please ensure this field '{{entity_field.relational_key.uncapitalized}}' is loaded in the '{{entity.name.capitalized}}' entity loader for this entity with id ${ {{entity.name.uncapitalized}}.id }.

It is also possible that you have saved an ID for an entity that doesn't exist in the code. Please validate in the Database that an entity of type '{{entity_field.mapped_entity.original}}' with ID ${ {{#if entity_field.is_optional}} {{entity_field.relational_key.uncapitalized}}_field  {{else}} {{entity.name.uncapitalized}}.{{entity_field.relational_key.uncapitalized}}_id  {{/if}} } exists. If it doesn't you need to examine the code that is meant to create and save that entity initially.`)

                raise(
                  LinkedEntityNotAvailableInSyncHandler(
                    "The required linked entity {{entity_field.relational_key.uncapitalized}} was not defined in the loader for entity {{entity.name.capitalized}}",
                  ),
                )
                 }
          {{#if entity_field.is_optional}})->Some
          | None => None
          }
              {{/if}}
            },
            {{/each}}
            },
          {{/each}}
        }
      }

      let getHandlerContextAsync= (): handlerContextAsync => {
          {{#each ../../entities as | entity |}}
            {{#each event.required_entities as | required_entity |}}
              {{#if (eq entity.name.capitalized required_entity.name.capitalized)}}
                {{#if required_entity.labels}}
                  {{#each required_entity.labels as |label| }}
                  let {{label}}_{{required_entity.name.capitalized}} = switch optIdOf_{{label}}.contents {
                    | Some(id) => inMemoryStore.{{required_entity.name.uncapitalized}}->IO.InMemoryStore.{{required_entity.name.capitalized}}.get(id)
                    | None =>
                      Logging.warn(`The loader for "{{label}}" of entity type "{{required_entity.name.capitalized}}"" was not used please add it to your loader function or remove it from your config.yaml file to avoid unexpected behaviour. This is a runtime validation check.`)
                      None
                    }
                  {{/each}}
                {{/if}}
                {{#if required_entity.array_labels}}
                  {{#each required_entity.array_labels as |array_label| }}
                  let {{array_label}}_{{required_entity.name.capitalized}} = switch optIdArrayOf_{{array_label}}.contents {
                    | Some(ids) =>
                      ids->Belt.Array.map(id => inMemoryStore.{{required_entity.name.uncapitalized}}->IO.InMemoryStore.{{required_entity.name.capitalized}}.get(id))
                    | None =>
                      Logging.warn(`The array loader for "{{array_label}}" of entity type "{{required_entity.name.capitalized}}"" was not used please add it to your loader function or remove it from your config.yaml file to avoid unexpected behaviour. This is a runtime validation check.`)
                      []
                    }
                  {{/each}}
                {{/if}}
              {{/if}}
            {{/each}}
          {{/each}}
        {
          log: contextLogger,
          {{#each ../../entities as | entity |}}
            {{entity.name.uncapitalized}}: {
              set: entity => {inMemoryStore.{{entity.name.uncapitalized}}->IO.InMemoryStore.{{entity.name.capitalized}}.set(
                ~key=entity.id,
                ~entity=Set(entity)->Types.mkEntityUpdate(~eventIdentifier),
              )},
              deleteUnsafe: id => {
                inMemoryStore.{{entity.name.uncapitalized}}->IO.InMemoryStore.{{entity.name.capitalized}}.set(
                ~key=id,
                ~entity=Delete(id)->Types.mkEntityUpdate(~eventIdentifier),
              )
                },
              {{#each event.required_entities as | required_entity |}}
                {{#if (eq entity.name.capitalized required_entity.name.capitalized)}}
                  {{#if required_entity.labels}}
                  {{#each required_entity.labels as |label| }}
                  {{label}}: {{label}}_{{required_entity.name.capitalized}},
                  {{/each}}
                  {{/if}}
                  {{#if required_entity.array_labels}}
                  {{#each required_entity.array_labels as |array_label| }}
                  {{array_label}}: {{array_label}}_{{required_entity.name.capitalized}},
                  {{/each}}
                  {{/if}}
                  get: async (id: Types.id) => {
                    if (optSetOfIds_{{required_entity.name.uncapitalized}}->Set.has(id)) {
                      inMemoryStore.{{required_entity.name.uncapitalized}}->IO.InMemoryStore.{{required_entity.name.capitalized}}.get(id)
                    } else {
                      // NOTE: this will still return the value if it exists in the in-memory store (despite the loader not being run).
                      switch inMemoryStore.{{required_entity.name.uncapitalized}}->IO.InMemoryStore.{{required_entity.name.capitalized}}.get(id) {
                      | Some(entity) => Some(entity)
                      | None =>
                        let entities = await asyncGetters.get{{required_entity.name.capitalized}}(id)

                        let optEntity = entities->Belt.Array.get(0)

                        IO.InMemoryStore.{{required_entity.name.capitalized}}.initValue(
                          inMemoryStore.{{required_entity.name.uncapitalized}},
                          ~key=id,
                          ~entity=optEntity,
                        )

                        optEntity
                      }
                    }
                 },
                {{/if}}
              {{/each}}
              {{#each entity.relational_params.filtered_not_derived_from as | entity_field |}}
              get{{entity_field.relational_key.capitalized}}: async {{entity.name.uncapitalized}} => {
                {{#if entity_field.is_optional}}
                 switch {{entity.name.uncapitalized}}.{{entity_field.relational_key.uncapitalized}}_id {
                  | Some({{entity_field.relational_key.uncapitalized}}_field) =>
                    // TODO: we aren't handling the case where the code is an optional array. Maybe we should enforce that at the compile step, and force users to use an empty array instead.
                    let opt{{entity_field.relational_key.capitalized}} = inMemoryStore.{{entity_field.mapped_entity.uncapitalized}}->IO.InMemoryStore.{{entity_field.mapped_entity.capitalized}}.get({{entity_field.relational_key.uncapitalized}}_field)
                 
                {{else}}
                  let {{entity_field.relational_key.uncapitalized}}_field = {{entity.name.uncapitalized}}.{{entity_field.relational_key.uncapitalized}}_id
                  let opt{{entity_field.relational_key.capitalized}} = inMemoryStore.{{entity_field.mapped_entity.uncapitalized}}->IO.InMemoryStore.{{entity_field.mapped_entity.capitalized}}.get({{entity_field.relational_key.uncapitalized}}_field)
                {{/if}}
                  switch opt{{entity_field.relational_key.capitalized}} {
                  | Some({{entity_field.relational_key.uncapitalized}}) => {{entity_field.relational_key.uncapitalized}}
                  | None => 
                    let entities = await asyncGetters.get{{entity_field.mapped_entity.capitalized}}({{entity_field.relational_key.uncapitalized}}_field)

                    switch entities->Belt.Array.get(0) {
                    | Some(entity) =>
                      // TODO: make this work with the test framework too.
                      IO.InMemoryStore.{{entity_field.mapped_entity.capitalized}}.initValue(
                        inMemoryStore.{{entity_field.mapped_entity.uncapitalized}},
                        ~key=entity.id,
                        ~entity=Some(entity),
                      )
                      entity
                    | None =>
                      Logging.error(`{{entity.name.capitalized}} {{entity_field.relational_key.uncapitalized}} data not found. Loading associated {{entity_field.mapped_entity.uncapitalized}} from database.
This is likely due to a database corruption. Please reach out to the team on discord.
`)

                  raise(
                    UnableToLoadNonNullableLinkedEntity(
                      "The required linked entity {{entity_field.relational_key.uncapitalized}} of {{entity.name.capitalized}} is undefined.",
                    ),
                  )
                }
               }
          {{#if entity_field.is_optional}}
          ->Some
          | None => None
          }
              {{/if}}
            },
            {{/each}}
            },
          {{/each}}
        }
      }

      {
        logger,
        log: contextLogger,
        getEntitiesToLoad: () => entitiesToLoad,
        getAddedDynamicContractRegistrations: () => addedDynamicContractRegistrations,
        getLoaderContext: () => loaderContext,
        getHandlerContextSync,
        getHandlerContextAsync,
      }
    }
  }
{{/each}}
}
{{/each}}

type eventAndContext =
{{#each codegen_contracts as | contract |}}
{{#each contract.codegen_events as | event |}}
  | {{contract.name.capitalized}}Contract_{{event.name.capitalized}}WithContext(
      Types.eventLog<Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs>,
      {{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.context
      )
{{/each}}
{{/each}}

type eventRouterEventAndContext = {
  chainId: int,
  event: eventAndContext,
}
