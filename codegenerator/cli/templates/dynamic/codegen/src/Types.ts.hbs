// This file is to dynamically generate TS types
// which we can't get using GenType
// Use @genType.import to link the types back to ReScript code

import type { Logger, IndexerFromConfig, EffectCaller, IndexerConfig } from "envio";
import type * as Entities from "./db/Entities.gen.ts";
import type config from "../internal.config.ts";

{{!-- 
TODO: Create envio-env.d.ts at the root of the project
when we completely get rid of codegen
declare module "envio" {
  interface Global {
    config: typeof config;
  }
} --}}
interface Global {
  config: typeof config;
}

// Helper to extract config from Global if it exists
type GlobalIndexerConfig = Global extends { config: infer C } ? C : never;

/** Union of all configured EVM chain names. */
export type EvmChainName = GlobalIndexerConfig extends { evm: infer Evm }
  ? Evm extends {
      chains: Record<infer K extends string, any>;
    }
    ? K
    : "EvmChainName is not available. Configure EVM chains in config.yaml and run 'pnpm envio codegen'"
  : "EvmChainName is not available. Configure EVM chains in config.yaml and run 'pnpm envio codegen'";

/** Union of all configured EVM chain IDs. */
export type EvmChainId = GlobalIndexerConfig extends { evm: infer Evm }
  ? Evm extends {
      chains: Record<string, { id: infer T extends number }>;
    }
    ? T
    : "EvmChainId is not available. Configure EVM chains in config.yaml and run 'pnpm envio codegen'"
  : "EvmChainId is not available. Configure EVM chains in config.yaml and run 'pnpm envio codegen'";

/** Union of all configured Fuel chain names. */
export type FuelChainName = GlobalIndexerConfig extends { fuel: infer Fuel }
  ? Fuel extends {
      chains: Record<infer K extends string, any>;
    }
    ? K
    : "FuelChainName is not available. Configure Fuel chains in config.yaml and run 'pnpm envio codegen'"
  : "FuelChainName is not available. Configure Fuel chains in config.yaml and run 'pnpm envio codegen'";

/** Union of all configured Fuel chain IDs. */
export type FuelChainId = GlobalIndexerConfig extends { fuel: infer Fuel }
  ? Fuel extends {
      chains: Record<string, { id: infer T extends number }>;
    }
    ? T
    : "FuelChainId is not available. Configure Fuel chains in config.yaml and run 'pnpm envio codegen'"
  : "FuelChainId is not available. Configure Fuel chains in config.yaml and run 'pnpm envio codegen'";

/** Union of all configured SVM chain names. */
export type SvmChainName = GlobalIndexerConfig extends { svm: infer Svm }
  ? Svm extends {
      chains: Record<infer K extends string, any>;
    }
    ? K
    : "SvmChainName is not available. Configure SVM chains in config.yaml and run 'pnpm envio codegen'"
  : "SvmChainName is not available. Configure SVM chains in config.yaml and run 'pnpm envio codegen'";

/** Union of all configured SVM chain IDs. */
export type SvmChainId = GlobalIndexerConfig extends { svm: infer Svm }
  ? Svm extends {
      chains: Record<string, { id: infer T extends number }>;
    }
    ? T
    : "SvmChainId is not available. Configure SVM chains in config.yaml and run 'pnpm envio codegen'"
  : "SvmChainId is not available. Configure SVM chains in config.yaml and run 'pnpm envio codegen'";

/** The indexer type. */
export type Indexer = Global extends {
  config: infer Config extends IndexerConfig;
}
  ? IndexerFromConfig<Config>
  : "The Indexer type is not available. Run 'pnpm envio codegen' to generate types";

export type ChainId = {{#if is_evm_ecosystem}}EvmChainId{{/if}}{{#if is_fuel_ecosystem}}FuelChainId{{/if}}{{#if is_svm_ecosystem}}SvmChainId{{/if}}

// ============== Test Indexer Types ==============

import type {
  TestIndexerFromConfig,
} from "envio";

/** The test indexer type. Allows running the indexer for specific block ranges and inspecting results. */
export type TestIndexer = Global extends {
  config: infer Config extends IndexerConfig;
}
  ? TestIndexerFromConfig<Config>
  : "The TestIndexer type is not available. Run 'pnpm envio codegen' to generate types";

export type HandlerContext = {
  /**
   * Access the logger instance with event as a context. The logs will be displayed in the console and Envio Hosted Service.
   */
  readonly log: Logger;
  /**
   * Call the provided Effect with the given input.
   * Effects are the best for external calls with automatic deduplication, error handling and caching.
   * Define a new Effect using createEffect outside of the handler.
   */
  readonly effect: EffectCaller;
  /**
   * True when the handlers run in preload mode - in parallel for the whole batch.
   * Handlers run twice per batch of events, and the first time is the "preload" run
   * During preload entities aren't set, logs are ignored and exceptions are silently swallowed.
   * Preload mode is the best time to populate data to in-memory cache.
   * After preload the handler will run for the second time in sequential order of events.
   */
  readonly isPreload: boolean;
  /**
   * Chain state information for the current event's chain.
   * - id: the chain ID
   * - isLive: true when the chain has completed initial sync and is processing live events,
   *            false during historical synchronization
   */
  readonly chain: {
    readonly id: ChainId;
    readonly isLive: boolean;
  };
  {{#each entities as | entity |}}
  readonly {{entity.name.original}}: {
    /**
     * Load the entity {{entity.name.original}} from the storage by ID.
     * If the entity is not found, returns undefined.
     */
    readonly get: (id: string) => Promise<Entities.{{entity.name.capitalized}}_t | undefined>,
    /**
     * Load the entity {{entity.name.original}} from the storage by ID.
     * If the entity is not found, throws an error.
     */
    readonly getOrThrow: (id: string, message?: string) => Promise<Entities.{{entity.name.capitalized}}_t>,
    readonly getWhere: Entities.{{entity.name.capitalized}}_indexedFieldOperations,
    /**
     * Returns the entity {{entity.name.original}} from the storage by ID.
     * If the entity is not found, creates it using provided parameters and returns it.
     */
    readonly getOrCreate: (entity: Entities.{{entity.name.capitalized}}_t) => Promise<Entities.{{entity.name.capitalized}}_t>,
    /**
     * Set the entity {{entity.name.original}} in the storage.
     */
    readonly set: (entity: Entities.{{entity.name.capitalized}}_t) => void,
    /**
     * Delete the entity {{entity.name.original}} from the storage.
     *
     * The 'deleteUnsafe' method is experimental and unsafe. You should manually handle all entity references after deletion to maintain database consistency.
     */
    readonly deleteUnsafe: (id: string) => void,
  }
  {{/each}}
};

{{#each entities as | entity |}}
export type {{entity.name.capitalized}} = Entities.{{entity.name.capitalized}}_t;
{{/each}}
