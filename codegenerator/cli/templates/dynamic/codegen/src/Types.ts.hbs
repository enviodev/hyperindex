// This file is to dynamically generate TS types
// which we can't get using GenType
// Use @genType.import to link the types back to ReScript code

import type { Logger, IndexerFromConfig, EffectCaller } from "envio";
import type * as Entities from "./db/Entities.gen.ts";
import type { EvmChains, EvmContracts, FuelChains, FuelContracts, SvmChains } from "../envio.d.ts";

// Utility type to check if an object type is empty
type IsEmptyObject<T> = keyof T extends never ? true : false;

/** Union of all configured EVM chain names. */
export type EvmChainName = IsEmptyObject<EvmChains> extends true
  ? "EvmChainName is not available. Configure EVM chains in config.yaml and run 'pnpm envio codegen'"
  : keyof EvmChains;

/** Union of all configured EVM chain IDs. */
export type EvmChainId = IsEmptyObject<EvmChains> extends true
  ? "EvmChainId is not available. Configure EVM chains in config.yaml and run 'pnpm envio codegen'"
  : EvmChains[keyof EvmChains]["id"];

/** Union of all configured EVM contract names. */
export type EvmContractName = IsEmptyObject<EvmContracts> extends true
  ? "EvmContractName is not available. Configure EVM contracts in config.yaml and run 'pnpm envio codegen'"
  : keyof EvmContracts;

/** Union of all configured Fuel chain names. */
export type FuelChainName = IsEmptyObject<FuelChains> extends true
  ? "FuelChainName is not available. Configure Fuel chains in config.yaml and run 'pnpm envio codegen'"
  : keyof FuelChains;

/** Union of all configured Fuel chain IDs. */
export type FuelChainId = IsEmptyObject<FuelChains> extends true
  ? "FuelChainId is not available. Configure Fuel chains in config.yaml and run 'pnpm envio codegen'"
  : FuelChains[keyof FuelChains]["id"];

/** Union of all configured Fuel contract names. */
export type FuelContractName = IsEmptyObject<FuelContracts> extends true
  ? "FuelContractName is not available. Configure Fuel contracts in config.yaml and run 'pnpm envio codegen'"
  : keyof FuelContracts;

/** Union of all configured SVM chain names. */
export type SvmChainName = IsEmptyObject<SvmChains> extends true
  ? "SvmChainName is not available. Configure SVM chains in config.yaml and run 'pnpm envio codegen'"
  : keyof SvmChains;

/** Union of all configured SVM chain IDs. */
export type SvmChainId = IsEmptyObject<SvmChains> extends true
  ? "SvmChainId is not available. Configure SVM chains in config.yaml and run 'pnpm envio codegen'"
  : SvmChains[keyof SvmChains]["id"];

// Construct config type from generated types
type Config = (IsEmptyObject<EvmChains> extends true
  ? {}
  : {
      evm: { chains: EvmChains; contracts: EvmContracts };
    }) &
  (IsEmptyObject<FuelChains> extends true
    ? {}
    : {
        fuel: { chains: FuelChains; contracts: FuelContracts };
      }) &
  (IsEmptyObject<SvmChains> extends true
    ? {}
    : {
        svm: { chains: SvmChains };
      });

/** The indexer type. */
export type Indexer = IndexerFromConfig<Config>;

export type ChainId = IsEmptyObject<EvmChains> extends false
  ? EvmChains[keyof EvmChains]["id"]
  : IsEmptyObject<FuelChains> extends false
  ? FuelChains[keyof FuelChains]["id"]
  : IsEmptyObject<SvmChains> extends false
  ? SvmChains[keyof SvmChains]["id"]
  : "ChainId is not available. Configure chains in config.yaml and run 'pnpm envio codegen'";

// ============== Test Indexer Types ==============

import type {
  TestIndexerFromConfig,
} from "envio";

/** The test indexer type. Allows running the indexer for specific block ranges and inspecting results. */
export type TestIndexer = TestIndexerFromConfig<Config>;

export type HandlerContext = {
  /**
   * Access the logger instance with event as a context. The logs will be displayed in the console and Envio Hosted Service.
   */
  readonly log: Logger;
  /**
   * Call the provided Effect with the given input.
   * Effects are the best for external calls with automatic deduplication, error handling and caching.
   * Define a new Effect using createEffect outside of the handler.
   */
  readonly effect: EffectCaller;
  /**
   * True when the handlers run in preload mode - in parallel for the whole batch.
   * Handlers run twice per batch of events, and the first time is the "preload" run
   * During preload entities aren't set, logs are ignored and exceptions are silently swallowed.
   * Preload mode is the best time to populate data to in-memory cache.
   * After preload the handler will run for the second time in sequential order of events.
   */
  readonly isPreload: boolean;
  /**
   * Chain state information for the current event's chain.
   * - id: the chain ID
   * - isLive: true when the chain has completed initial sync and is processing live events,
   *            false during historical synchronization
   */
  readonly chain: {
    readonly id: ChainId;
    readonly isLive: boolean;
  };
  {{#each entities as | entity |}}
  readonly {{entity.name.original}}: {
    /**
     * Load the entity {{entity.name.original}} from the storage by ID.
     * If the entity is not found, returns undefined.
     */
    readonly get: (id: string) => Promise<Entities.{{entity.name.capitalized}}_t | undefined>,
    /**
     * Load the entity {{entity.name.original}} from the storage by ID.
     * If the entity is not found, throws an error.
     */
    readonly getOrThrow: (id: string, message?: string) => Promise<Entities.{{entity.name.capitalized}}_t>,
    readonly getWhere: Entities.{{entity.name.capitalized}}_indexedFieldOperations,
    /**
     * Returns the entity {{entity.name.original}} from the storage by ID.
     * If the entity is not found, creates it using provided parameters and returns it.
     */
    readonly getOrCreate: (entity: Entities.{{entity.name.capitalized}}_t) => Promise<Entities.{{entity.name.capitalized}}_t>,
    /**
     * Set the entity {{entity.name.original}} in the storage.
     */
    readonly set: (entity: Entities.{{entity.name.capitalized}}_t) => void,
    /**
     * Delete the entity {{entity.name.original}} from the storage.
     *
     * The 'deleteUnsafe' method is experimental and unsafe. You should manually handle all entity references after deletion to maintain database consistency.
     */
    readonly deleteUnsafe: (id: string) => void,
  }
  {{/each}}
};

{{#each entities as | entity |}}
export type {{entity.name.capitalized}} = Entities.{{entity.name.capitalized}}_t;
{{/each}}
