
/***** TAKE NOTE ******
This file module is a hack to get genType to work!

In order for genType to produce recursive types, it needs to be at the 
root module of a file. If it's defined in a nested module it does not 
work. So all the MockDb types and internal functions are defined here in TestHelpers_MockDb
and only public functions are recreated and exported from TestHelpers.MockDb module.

the following module:
```rescript
module MyModule = {
  @genType
  type rec a = {fieldB: b}
  @genType and b = {fieldA: a}
}
```

produces the following in ts:
```ts
// tslint:disable-next-line:interface-over-type-literal
export type MyModule_a = { readonly fieldB: b };

// tslint:disable-next-line:interface-over-type-literal
export type MyModule_b = { readonly fieldA: MyModule_a };
```

fieldB references type b which doesn't exist because it's defined
as MyModule_b
*/

open Belt

let mockEventRegisters = Utils.WeakMap.make()

/**
A raw js binding to allow deleting from a dict. Used in store delete operation
*/
let deleteDictKey: (dict<'a>, string) => unit = %raw(`
    function(dict, key) {
      delete dict[key]
    }
  `)

let config = Generated.configWithoutRegistrations

/**
The mockDb type is simply an InMemoryStore internally. __dbInternal__ holds a reference
to an inMemoryStore and all the the accessor methods point to the reference of that inMemory
store
*/
@genType.opaque
type inMemoryStore = InMemoryStore.t

@genType
type rec t = {
  __dbInternal__: inMemoryStore,
  entities: entities,
  rawEvents: storeOperations<InMemoryStore.rawEventsKey, InternalTable.RawEvents.t>,
  dynamicContractRegistry: entityStoreOperations<InternalTable.DynamicContractRegistry.t>,
  processEvents: array<Types.eventLog<unknown>> => promise<t>,
}

// Each user defined entity will be in this record with all the store or "mockdb" operators
@genType
and entities = {
  {{#each entities as | entity |}}
    @as("{{entity.name.original}}") {{entity.name.uncapitalized}}: entityStoreOperations<Entities.{{entity.name.capitalized}}.t>,
  {{/each}}
  }
// User defined entities always have a string for an id which is used as the
// key for entity stores
@genType
and entityStoreOperations<'entity> = storeOperations<string, 'entity>
// all the operator functions a user can access on an entity in the mock db
// stores refer to the the module that MakeStore functor outputs in IO.res
@genType
and storeOperations<'entityKey, 'entity> = {
  getAll: unit => array<'entity>,
  get: 'entityKey => option<'entity>,
  set: 'entity => t,
  delete: 'entityKey => t,
}

/**
a composable function to make the "storeOperations" record to represent all the mock
db operations for each entity.
*/
let makeStoreOperatorEntity = (
  ~inMemoryStore: InMemoryStore.t,
  ~makeMockDb,
  ~getStore: InMemoryStore.t => InMemoryTable.Entity.t<'entity>,
  ~getKey: 'entity => Types.id,
): storeOperations<Types.id, 'entity> => {
  let {getUnsafe, values, set} = module(InMemoryTable.Entity)

  let get = id => {
    let store = inMemoryStore->getStore
    if store.table->InMemoryTable.hasByHash(id) {
      getUnsafe(store)(id)
    } else {
      None
    }
  }

  let getAll = () =>
    inMemoryStore
    ->getStore
    ->values

  let delete = entityId => {
    let cloned = inMemoryStore->InMemoryStore.clone
    let table = cloned->getStore

    table->set(
      Delete({
        entityId,
        checkpointId: 0.,
      }),
      ~shouldSaveHistory=false,
    )

    cloned->makeMockDb
  }

  let set = entity => {
    let cloned = inMemoryStore->InMemoryStore.clone
    let table = cloned->getStore
    let entityId = entity->getKey

    table->set(
      Set({
        entityId,
        checkpointId: 0.,
        entity,
      }),
      ~shouldSaveHistory=false,
    )

    cloned->makeMockDb
  }

  {
    getAll,
    get,
    set,
    delete,
  }
}

let makeStoreOperatorMeta = (
  ~inMemoryStore: InMemoryStore.t,
  ~makeMockDb,
  ~getStore: InMemoryStore.t => InMemoryTable.t<'key, 'value>,
  ~getKey: 'value => 'key,
): storeOperations<'key, 'value> => {
  let {get, values, set} = module(InMemoryTable)

  let get = id => get(inMemoryStore->getStore, id)

  let getAll = () => inMemoryStore->getStore->values->Array.map(row => row)

  let set = metaData => {
    let cloned = inMemoryStore->InMemoryStore.clone
    cloned->getStore->set(metaData->getKey, metaData)
    cloned->makeMockDb
  }

  // TODO: Remove. Is delete needed for meta data?
  let delete = key => {
    let cloned = inMemoryStore->InMemoryStore.clone
    let store = cloned->getStore
    store.dict->deleteDictKey(key->store.hash)
    cloned->makeMockDb
  }

  {
    getAll,
    get,
    set,
    delete,
  }
}

/**
Accessor function for getting the internal inMemoryStore in the mockDb
*/
let getInternalDb = (self: t) => self.__dbInternal__

let getEntityOperations = (mockDb: t, ~entityName: string): entityStoreOperations<
  Internal.entity,
> => {
  mockDb.entities
  ->Utils.magic
  ->Utils.Dict.dangerouslyGetNonOption(entityName)
  ->Utils.Option.getExn("Mocked operations for entity " ++ entityName ++ " not found")
}

/**
A function composer for simulating the writing of an inMemoryStore to the external db with a mockDb.
Runs all set and delete operations currently cached in an inMemory store against the mockDb
*/
let executeRowsEntity = (
  mockDb: t,
  ~inMemoryStore: InMemoryStore.t,
  ~entityConfig: Internal.entityConfig,
) => {
  let getInMemTable = (inMemoryStore: InMemoryStore.t) =>
    inMemoryStore->InMemoryStore.getInMemTable(~entityConfig)

  let inMemTable = getInMemTable(inMemoryStore)

  inMemTable.table
  ->InMemoryTable.values
  ->Array.forEach(row => {
    let mockDbTable = mockDb->getInternalDb->getInMemTable
    switch row {
    | {status: Updated({latestChange: Set({entity})})}
    | {status: Loaded, latest: Some(entity)} => {
        let key = (entity: Internal.entity).id
        mockDbTable->InMemoryTable.Entity.initValue(
          ~allowOverWriteEntity=true,
          ~key,
          ~entity=Some(entity),
        )
      }

    | {status: Updated({latestChange: Delete({entityId})})} =>
      mockDbTable.table.dict->deleteDictKey(entityId)
    | {status: Loaded, latest: None} => ()
    }
  })
}

let executeRowsMeta = (
  mockDb: t,
  ~inMemoryStore: InMemoryStore.t,
  ~getInMemTable: InMemoryStore.t => InMemoryTable.t<'key, 'entity>,
  ~getKey: 'entity => 'key,
) => {
  let mockDbTable = mockDb->getInternalDb->getInMemTable
  inMemoryStore
  ->getInMemTable
  ->InMemoryTable.values
  ->Array.forEach(row => {
    mockDbTable->InMemoryTable.set(getKey(row), row)
  })
}

/**
The internal make function which can be passed an in memory store and
instantiate a "MockDb". This is useful for cloning or making a MockDb
out of an existing inMemoryStore
*/
let rec makeWithInMemoryStore: InMemoryStore.t => t = (inMemoryStore: InMemoryStore.t) => {
  let rawEvents = makeStoreOperatorMeta(
    ~inMemoryStore,
    ~makeMockDb=makeWithInMemoryStore,
    ~getStore=db => db.rawEvents,
    ~getKey=({chainId, eventId}) => {
      chainId,
      eventId: eventId->BigInt.toString,
    },
  )

  let dynamicContractRegistry = makeStoreOperatorEntity(
    ~inMemoryStore,
    ~getStore=db =>
      db
      ->InMemoryStore.getInMemTable(
        ~entityConfig=InternalTable.DynamicContractRegistry.config,
      )
      ->(
        Utils.magic: InMemoryTable.Entity.t<Internal.entity> => InMemoryTable.Entity.t<
          InternalTable.DynamicContractRegistry.t,
        >
      ),
    ~makeMockDb=makeWithInMemoryStore,
    ~getKey=({chainId, contractAddress}) => {
      InternalTable.DynamicContractRegistry.makeId(~chainId, ~contractAddress)
    },
  )

  let entities = {
  {{#each entities as | entity |}}
      {{entity.name.uncapitalized}}: {
        makeStoreOperatorEntity(
          ~inMemoryStore,
          ~makeMockDb=makeWithInMemoryStore,
          ~getStore=db => db->InMemoryStore.getInMemTable(
            ~entityConfig=module(Entities.{{entity.name.capitalized}})->Entities.entityModToInternal,
          )->(
            Utils.magic: InMemoryTable.Entity.t<Internal.entity> => InMemoryTable.Entity.t<
              Entities.{{entity.name.capitalized}}.t,
            >
          ),
          ~getKey=({id}) => id,
        )
      },
  {{/each}}
  }

  let mockDb = {
    __dbInternal__: inMemoryStore,
    entities,
    rawEvents,
    dynamicContractRegistry,
    processEvents: %raw(`null`),
  }
  (mockDb->Utils.magic)["processEvents"] = makeProcessEvents(mockDb, ~chainId=?None)
  mockDb
}
and makeProcessEvents = (mockDb: t, ~chainId=?) => async (
  events: array<Types.eventLog<unknown>>,
) => {
  if events->Utils.Array.isEmpty {
    mockDb
  } else {
    let itemsWithContractRegister = []

    let registrations = if EventRegister.isPendingRegistration() {
      EventRegister.finishRegistration()
    } else {
      await HandlerLoader.registerAllHandlers(~config)
    }

    let config = Generated.makeGeneratedConfig()
    let ctx: Ctx.t = {
      registrations,
      config,
      persistence: Generated.codegenPersistence,
    }

    let processingChainId = ref(chainId)
    let latestFetchedBlockNumber = ref(0)
    let newItems = events->Array.map(event => {
      let event = event->Internal.fromGenericEvent
      let eventConfig: Internal.eventConfig = switch mockEventRegisters->Utils.WeakMap.get(event) {
      | Some(register) => register()
      | None =>
        Js.Exn.raiseError(
          "Events must be created using the mock API (e.g. createMockEvent) to be processed by mockDb.processEvents",
        )
      }

      switch eventConfig {
      | {handler: None, contractRegister: None} => Js.Exn.raiseError(`Event ${eventConfig.contractName}.${eventConfig.name} has no handler or contract register`)
      | _ => ()
      }

      let chainId = switch chainId {
      | Some(chainId) => chainId
      | None => event.chainId
      }

      switch processingChainId.contents {
      | Some(prevItemChainId) =>
        if prevItemChainId !== chainId {
          Js.Exn.raiseError(
            `Processing events on multiple chains is not supported yet. Got chainId ${chainId->Belt.Int.toString} but expected ${prevItemChainId->Belt.Int.toString}`,
          )
        }
      | None => processingChainId.contents = Some(chainId)
      }

      let chain = config->Config.getChain(~chainId)
      let item = Internal.Event({
        eventConfig,
        event,
        chain,
        logIndex: event.logIndex,
        timestamp: event.block->config.ecosystem.getTimestamp,
        blockNumber: event.block->config.ecosystem.getNumber,
      })
      latestFetchedBlockNumber.contents = Pervasives.max(
        latestFetchedBlockNumber.contents,
        event.block->config.ecosystem.getNumber,
      )
      if eventConfig.contractRegister->Option.isSome {
        itemsWithContractRegister->Js.Array2.push(item)->ignore
      }
      item
    })

    let processingChainId = switch processingChainId.contents {
    | Some(chainId) => chainId
    | None =>
      Js.Exn.raiseError("No events provided to processEvents. Please provide at least one event.")
    }
    let processingChain = config->Config.getChain(~chainId=processingChainId)

    let chainFetcher = ChainFetcher.makeFromConfig(
      config.chainMap->ChainMap.get(processingChain),
      ~config,
      ~registrations=ctx.registrations,
      ~targetBufferSize=5000,
      ~knownHeight=latestFetchedBlockNumber.contents,
    )

    //Deep copy the data in mockDb, mutate the clone and return the clone
    //So no side effects occur here and state can be compared between process
    //steps
    let mockDbClone = mockDb->cloneMockDb

    //Construct a new instance of an in memory store to run for the given event
    let inMemoryStore = InMemoryStore.make(~entities=Entities.allEntities)
    let loadManager = LoadManager.make()
    let persistence = {
      ...ctx.persistence,
      storage: makeMockStorage(mockDb),
      storageStatus: Ready({
        cleanRun: false,
        cache: Js.Dict.empty(),
        chains: [],
        reorgCheckpoints: [],
        checkpointId: 0.,
      }),
    }
    let ctx = {
      ...ctx,
      persistence,
    }

    let newItemsWithDcs = if itemsWithContractRegister->Utils.Array.notEmpty {
      await ChainFetcher.runContractRegistersOrThrow(
        ~itemsWithContractRegister,
        ~chain=processingChain,
        ~config,
      )
    } else {
      itemsWithContractRegister
    }

    let updatedFetchState = ref(chainFetcher.fetchState)

    switch newItemsWithDcs {
    | [] => ()
    | _ =>
      updatedFetchState :=
        updatedFetchState.contents->FetchState.registerDynamicContracts(newItemsWithDcs)
    }

    // Handle query for all partitions
    let partitionIds = updatedFetchState.contents.optimizedPartitions.idsInAscOrder
    for idx in 0 to partitionIds->Array.length - 1 {
      let partitionId = partitionIds->Array.getUnsafe(idx)
      let query: FetchState.query = {
        partitionId,
        fromBlock: 0,
        selection: {eventConfigs: [], dependsOnAddresses: false},
        addressesByContractName: Js.Dict.empty(),
        toBlock: None,
        indexingContracts: Js.Dict.empty(),
        isChunk: false,
      }
      updatedFetchState.contents->FetchState.startFetchingQueries(~queries=[query])
      updatedFetchState :=
        updatedFetchState.contents->FetchState.handleQueryResult(
          ~latestFetchedBlock={
            blockNumber: latestFetchedBlockNumber.contents,
            blockTimestamp: 0,
          },
          ~query,
          ~newItems=if idx === 0 {
            newItems
          } else {
            []
          },
        )
    }

    let batch = Batch.prepareUnorderedBatch(
      ~checkpointIdBeforeBatch=0.,
      ~chainsBeforeBatch=ChainMap.fromArrayUnsafe([
        (
          processingChain,
          (
            {
              fetchState: updatedFetchState.contents,
              reorgDetection: chainFetcher.reorgDetection,
              progressBlockNumber: chainFetcher.committedProgressBlockNumber,
              sourceBlockNumber: chainFetcher.fetchState.knownHeight,
              totalEventsProcessed: chainFetcher.numEventsProcessed,
            }: Batch.chainBeforeBatch
          ),
        ),
      ]),
      ~batchSizeTarget=newItems->Array.length,
    )

    inMemoryStore->InMemoryStore.setBatchDcs(~batch, ~shouldSaveHistory=false)

    // Create a mock chains state where the processing chain is ready (simulating "Live" mode)
    let chains = Js.Dict.empty()
    chains->Js.Dict.set(
      processingChainId->Int.toString,
      {id: processingChainId, Internal.isLive: true},
    )

    try {
      await batch->EventProcessing.preloadBatchOrThrow(
        ~loadManager,
        ~persistence,
        ~inMemoryStore,
        ~chains,
        ~config=ctx.config,
      )
      await batch->EventProcessing.runBatchHandlersOrThrow(
        ~inMemoryStore,
        ~loadManager,
        ~ctx,
        ~shouldSaveHistory=false,
        ~shouldBenchmark=false,
        ~chains,
      )
    } catch {
    | EventProcessing.ProcessingError({message, exn, item}) =>
      exn
      ->ErrorHandling.make(~msg=message, ~logger=item->Logging.getItemLogger)
      ->ErrorHandling.logAndRaise
    }

    //In mem store can still contatin raw events and dynamic contracts for the
    //testing framework in cases where either contract register or loaderHandler
    //is None
    mockDbClone->writeFromMemoryStore(~inMemoryStore)
    mockDbClone
  }
}
and makeMockStorage = (mockDb: t): Persistence.storage => {
  {
    isInitialized: () => Js.Exn.raiseError("Not used yet"),
    initialize: (~chainConfigs as _=?, ~entities as _=?, ~enums as _=?) =>
      Js.Exn.raiseError("Not used yet"),
    resumeInitialState: () => Js.Exn.raiseError("Not used yet"),
    loadByIdsOrThrow: (
      type item,
      ~ids,
      ~table: Table.table,
      ~rowsSchema as _: S.t<array<item>>,
    ) => {
      let operations = mockDb->getEntityOperations(~entityName=table.tableName)
      ids
      ->Array.keepMap(id => operations.get(id))
      ->(Utils.magic: array<Internal.entity> => array<item>)
      ->Promise.resolve
    },
    loadByFieldOrThrow: (
      ~fieldName,
      ~fieldSchema as _,
      ~fieldValue,
      ~operator,
      ~table,
      ~rowsSchema as _,
    ) => {
      let mockDbTable =
        mockDb.__dbInternal__.entities->InMemoryStore.EntityTables.get(~entityName=table.tableName)
      let index = TableIndices.Index.makeSingle(
        ~fieldName,
        ~fieldValue,
        ~operator=switch operator {
        | #"=" => Eq
        | #">" => Gt
        | #"<" => Lt
        },
      )
      mockDbTable
      ->InMemoryTable.Entity.values
      ->Array.keep(entity => {
        index->TableIndices.Index.evaluate(
          ~fieldName,
          ~fieldValue=entity->Utils.magic->Js.Dict.unsafeGet(fieldName),
        )
      })
      ->Promise.resolve
    },
    setOrThrow: (~items as _, ~table as _, ~itemSchema as _) => Js.Exn.raiseError("Not used yet"),
    setEffectCacheOrThrow: (~effect as _, ~items as _, ~initialize as _) => Promise.resolve(),
    dumpEffectCache: () => Js.Exn.raiseError("Not used yet"),
    executeUnsafe: _ => Js.Exn.raiseError("Not used yet"),
    setChainMeta: _ => Promise.resolve(%raw(`undefined`)),
    pruneStaleCheckpoints: (~safeCheckpointId as _) => Js.Exn.raiseError("Not used yet"),
    pruneStaleEntityHistory: (~entityName as _, ~entityIndex as _, ~safeCheckpointId as _) =>
      Js.Exn.raiseError("Not used yet"),
    getRollbackTargetCheckpoint: (~reorgChainId as _, ~lastKnownValidBlockNumber as _) =>
      Js.Exn.raiseError("Not used yet"),
    getRollbackProgressDiff: (~rollbackTargetCheckpointId as _) =>
      Js.Exn.raiseError("Not used yet"),
    getRollbackData: (~entityConfig as _, ~rollbackTargetCheckpointId as _) =>
      Js.Exn.raiseError("Not used yet"),
    writeBatch: (
      ~batch as _,
      ~rawEvents as _,
      ~rollbackTargetCheckpointId as _,
      ~isInReorgThreshold as _,
      ~config as _,
      ~allEntities as _,
      ~updatedEffectsCache as _,
      ~updatedEntities as _,
    ) => Js.Exn.raiseError("Not used yet"),
  }
}
and /**
Deep copies the in memory store data and returns a new mockDb with the same
state and no references to data from the passed in mockDb
*/
cloneMockDb = (self: t) => {
  let clonedInternalDb = self->getInternalDb->InMemoryStore.clone
  clonedInternalDb->makeWithInMemoryStore
}
and /**
Simulates the writing of processed data in the inMemoryStore to a mockDb. This function
executes all the rows on each "store" (or pg table) in the inMemoryStore
*/
writeFromMemoryStore = (mockDb: t, ~inMemoryStore: InMemoryStore.t) => {
  //INTERNAL STORES/TABLES EXECUTION
  mockDb->executeRowsMeta(
    ~inMemoryStore,
    ~getInMemTable=inMemStore => {inMemStore.rawEvents},
    ~getKey=(entity): InMemoryStore.rawEventsKey => {
      chainId: entity.chainId,
      eventId: entity.eventId->BigInt.toString,
    },
  )

  Generated.codegenPersistence.allEntities->Array.forEach(entityConfig => {
    mockDb->executeRowsEntity(~inMemoryStore, ~entityConfig)
  })
}

/**
The constructor function for a mockDb. Call it and then set up the inital state by calling
any of the set functions it provides access to. A mockDb will be passed into a processEvent 
helper. Note, process event helpers will not mutate the mockDb but return a new mockDb with
new state so you can compare states before and after.
*/
@genType
let //Note: It's called createMockDb over "make" to make it more intuitive in JS and TS

createMockDb = () => makeWithInMemoryStore(InMemoryStore.make(~entities=Entities.allEntities))
