//*************
//***ENTITIES**
//*************
@genType.as("Id")
type id = string

@@warning("-30")
@genType
type rec {{#each entities as | entity |}}{{#unless @first}}
and {{/unless}}{{entity.name.uncapitalized}}LoaderConfig = {{#if entity.relational_params.filtered_not_derived_from.[0]}}{
  {{#each entity.relational_params.filtered_not_derived_from as | relational_param |}}
  load{{relational_param.relational_key.capitalized}}?: {{relational_param.mapped_entity.uncapitalized}}LoaderConfig,{{/each}}
}{{else}}bool{{/if}}{{/each}}
@@warning("+30")

@genType
type entityRead = 
{{#each entities as | entity |}}
| {{entity.name.capitalized}}Read(id{{#if entity.relational_params.filtered_not_derived_from.[0]}}, {{entity.name.uncapitalized}}LoaderConfig{{/if}})
{{/each}}

@genType
type rawEventsEntity = {
  @as("chain_id") chainId: int,
  @as("event_id") eventId: string,
  @as("block_number") blockNumber: int,
  @as("log_index") logIndex: int,
  @as("transaction_index") transactionIndex: int,
  @as("transaction_hash") transactionHash: string,
  @as("src_address") srcAddress: Ethers.ethAddress,
  @as("block_hash") blockHash: string,
  @as("block_timestamp") blockTimestamp: int,
  @as("event_type") eventType: Js.Json.t,
  params: string,
}

@genType
type dynamicContractRegistryEntity = {
  @as("chain_id") chainId: int,
  @as("event_id") eventId: Ethers.BigInt.t,
  @as("contract_address") contractAddress: Ethers.ethAddress,
  @as("contract_type") contractType: string,
}


{{#each entities as | entity |}}
@genType.as("{{entity.name.original}}Entity")
type {{entity.name.uncapitalized}}Entity = {
  {{#each entity.params as | param |}}
  {{#unless param.is_derived_from }}{{param.field_name.uncapitalized}}{{#if param.is_entity_field}}_id{{/if}}: {{param.type_rescript}},{{/unless}}
  {{/each}}
}

let {{entity.name.uncapitalized}}EntitySchema = S.object((. s) => {
  {{#each entity.params as | param |}}
  {{#unless param.is_derived_from }}{{param.field_name.uncapitalized}}{{#if param.is_entity_field}}_id{{/if}}: s.field("{{param.field_name.uncapitalized}}{{#if param.is_entity_field}}_id{{/if}}", {{param.type_rescript_schema}}),{{/unless}}
  {{/each}}
})
let {{entity.name.uncapitalized}}EntitiesSchema = S.array({{entity.name.uncapitalized}}EntitySchema)
 
{{/each}}
type entity = 
{{#each entities as | entity |}}
  | {{entity.name.capitalized}}Entity({{entity.name.uncapitalized}}Entity)
{{/each}}

type eventIdentifier = {
  chainId: int,
  blockTimestamp: int,
  blockNumber: int,
  logIndex: int,
}

type entityUpdate<'entityType> =
  | Set('entityType, eventIdentifier)
  | Delete(string, eventIdentifier)

type entityValueAtStartOfBatch<'entityType> =
  | NotSet // The entity isn't in the DB yet
  | AlreadySet('entityType)

type existingValueInDb<'entityType> =
  | Retrieved(entityValueAtStartOfBatch<'entityType>)
  // NOTE: We use an postgres function solve the issue of this entities previous value not being known.
  | Unknown

type updatedValue<'entityType> = {
  // Initial value within a batch
  initial: existingValueInDb<'entityType>,
  latest: entityUpdate<'entityType>,
  history: array<entityUpdate<'entityType>>,
}
@genType
type inMemoryStoreRowEntity<'entityType> =
  | Updated(updatedValue<'entityType>)
  | InitialReadFromDb(entityValueAtStartOfBatch<'entityType>) // This means there is no change from the db.

type inMemoryStoreRowMeta<'a> = 'a

//*************
//**CONTRACTS**
//*************

@genType.as("EventLog")
type eventLog<'a> = {
  params: 'a,
  chainId: int,
  txOrigin: option<Ethers.ethAddress>,
  blockNumber: int,
  blockTimestamp: int,
  blockHash: string,
  srcAddress: Ethers.ethAddress,
  transactionHash: string,
  transactionIndex: int,
  logIndex: int,
}

{{#each codegen_contracts as | contract |}}
module {{contract.name.capitalized}}Contract = {
{{#each contract.codegen_events as | event |}}
module {{event.name.capitalized}}Event = {
  //Note: each parameter is using a binding of its index to help with binding in ethers
  //This handles both unamed params and also named params that clash with reserved keywords
  //eg. if an event param is called "values" it will clash since eventArgs will have a '.values()' iterator
  type ethersEventArgs = 
    {{#if event.params}}
    {
      {{#each event.params as | param |}}
      @as("{{@index}}") {{param.param_name.uncapitalized}}: {{param.type_rescript}},
      {{/each}}
    }
    {{else}}
    unit
    {{/if}}

  @genType
  type eventArgs = 
    {{#if event.params}}
    {
      {{#each event.params as | param |}}
      {{param.param_name.uncapitalized}}: {{param.type_rescript}},
      {{/each}}
    }
    {{else}}
    unit
    {{/if}}
let eventArgsSchema = 
  {{#if event.params}}
  S.object((. s) => {
  {{#each event.params as | param |}}
    {{param.param_name.uncapitalized}}: s.field("{{param.param_name.uncapitalized}}", {{param.type_rescript_schema}}),
  {{/each}}
  })
  {{else}}
  S.literal(%raw(`null`))->S.variant((. _) => ())
  {{/if}}


  @genType.as("{{contract.name.capitalized}}Contract_{{event.name.capitalized}}_EventLog")
  type log = eventLog<eventArgs>

    {{#each ../../entities as | entity |}}

    // Entity: {{entity.name.original}}
    type {{entity.name.uncapitalized}}EntityHandlerContext = {
    {{#each event.required_entities as | required_entity |}}
      {{#if (eq entity.name.capitalized required_entity.name.capitalized)}}
        {{#if required_entity.labels}}
        {{#each required_entity.labels as |label| }}
        {{label}}: option<{{required_entity.name.uncapitalized}}Entity>,
        {{/each}}
        {{/if}}
        {{#if required_entity.array_labels}}
        {{#each required_entity.array_labels as |array_label| }}
        {{array_label}}: array<option<{{required_entity.name.uncapitalized}}Entity>>,
        {{/each}}
        {{/if}}
        get: id => option<{{required_entity.name.uncapitalized}}Entity>,
      {{/if}}

    {{/each}}
    {{#each entity.relational_params.filtered_not_derived_from as | entity_field |}}
        get{{entity_field.relational_key.capitalized}}: {{entity.name.uncapitalized}}Entity => 
        {{#if entity_field.is_optional}}
          option<{{entity_field.mapped_entity.uncapitalized}}Entity>
        {{else}}
          {{#if entity_field.is_array}}
            array<{{entity_field.mapped_entity.uncapitalized}}Entity>
          {{else}}
            {{entity_field.mapped_entity.uncapitalized}}Entity
          {{/if}}
        {{/if}},
      {{/each}}
      set: {{entity.name.uncapitalized}}Entity => unit,
      delete: id => unit,
    }

    type {{entity.name.uncapitalized}}EntityHandlerContextAsync = {
    {{#each event.required_entities as | required_entity |}}
      {{#if (eq entity.name.capitalized required_entity.name.capitalized)}}
        {{#if required_entity.labels}}
        {{#each required_entity.labels as |label| }}
        {{label}}: option<{{required_entity.name.uncapitalized}}Entity>,
        {{/each}}
        {{/if}}
        {{#if required_entity.array_labels}}
        {{#each required_entity.array_labels as |array_label| }}
        {{array_label}}: array<option<{{required_entity.name.uncapitalized}}Entity>>,
        {{/each}}
        {{/if}}
        get: id => promise<option<{{required_entity.name.uncapitalized}}Entity>>,
      {{/if}}

    {{/each}}
    {{#each entity.relational_params.filtered_not_derived_from as | entity_field |}}
        get{{entity_field.relational_key.capitalized}}: {{entity.name.uncapitalized}}Entity => 
        promise<{{#if entity_field.is_optional}}
          option<{{entity_field.mapped_entity.uncapitalized}}Entity>,
        {{else}}
          {{#if entity_field.is_array}}
          {{!-- NOTE: this case is currently impossible. However, we should make this work for `derivedFrom` fields. - see: https://github.com/Float-Capital/indexer/issues/1168 --}}
            array<{{entity_field.mapped_entity.uncapitalized}}Entity>,
          {{else}}
            {{entity_field.mapped_entity.uncapitalized}}Entity,
          {{/if}}
        {{/if}}
        >,
      {{/each}}
      set: {{entity.name.uncapitalized}}Entity => unit,
      delete: id => unit,
    }
    {{/each}}

    @genType
    type handlerContext = {
      log: Logs.userLogger,
      {{#each ../../entities as | entity |}}
        @as("{{entity.name.original}}") {{entity.name.uncapitalized}}: {{entity.name.uncapitalized}}EntityHandlerContext,
      {{/each}}
    }
    @genType
    type handlerContextAsync = {
      log: Logs.userLogger,
      {{#each ../../entities as | entity |}}
        @as("{{entity.name.original}}") {{entity.name.uncapitalized}}: {{entity.name.uncapitalized}}EntityHandlerContextAsync,
      {{/each}}
    }

    {{#each event.required_entities as | required_entity |}}
    @genType
    type {{required_entity.name.uncapitalized}}EntityLoaderContext = {
      {{#if required_entity.labels}}
      {{#each required_entity.labels as | label |}}
      {{label}}Load: (id{{#if required_entity.entity_fields_of_required_entity.filtered_not_derived_from.[0]}}, ~loaders: {{required_entity.name.uncapitalized}}LoaderConfig=?{{/if}}) => unit,
      {{/each}}
      {{/if}}
      {{#if required_entity.array_labels}}
      {{#each required_entity.array_labels as | array_label |}}
      {{array_label}}Load: (array<id>{{#if required_entity.entity_fields_of_required_entity.filtered_not_derived_from.[0]}}, ~loaders: {{required_entity.name.uncapitalized}}LoaderConfig=?{{/if}}) => unit,
      {{/each}}
      {{/if}}
      load: (id{{#if required_entity.entity_fields_of_required_entity.filtered_not_derived_from.[0]}}, ~loaders: {{required_entity.name.uncapitalized}}LoaderConfig=?{{/if}}) => unit,
    }
    {{/each}}

    
    @genType
    type contractRegistrations = {
    {{#each ../../codegen_contracts as |contract_inner| }}
      //TODO only add contracts we've registered for the event in the config
      add{{contract_inner.name.capitalized}}: (Ethers.ethAddress) => unit,
    {{/each}}
    }
    @genType
    type loaderContext = {
      log: Logs.userLogger,
      contractRegistration: contractRegistrations,
    {{#each event.required_entities as | required_entity |}}
      @as("{{required_entity.name.original}}") {{required_entity.name.uncapitalized}} : {{required_entity.name.uncapitalized}}EntityLoaderContext,
    {{/each}}
    }
}
{{/each}}
}
{{/each}}

type event =
{{#each codegen_contracts as | contract |}}
{{#each contract.codegen_events as | event |}}
  | {{contract.name.capitalized}}Contract_{{event.name.capitalized}}(eventLog<{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs>)
{{/each}}
{{/each}}

type eventName =
{{#each codegen_contracts as | contract |}}
{{#each contract.codegen_events as | event |}}
  | @as("{{event.event_type.truncated_for_pg_enum_limit}}") {{event.event_type.full}}
{{/each}}
{{/each}}
let eventNameSchema = S.union([
{{#each codegen_contracts as | contract |}}
{{#each contract.codegen_events as | event |}}
  S.literal({{event.event_type.full}}),
{{/each}}
{{/each}}
])

let eventNameToString = (eventName: eventName) => switch eventName {
  {{#each codegen_contracts as | contract |}}
  {{#each contract.codegen_events as | event |}}
    | {{event.event_type.full}} => "{{event.name.capitalized}}"
  {{/each}}
  {{/each}}
}

exception UnknownEvent(string, string)
let eventTopicToEventName = (contractName, topic0) =>
  switch (contractName, topic0) {
{{#each codegen_contracts as | contract |}}
{{#each contract.codegen_events as | event |}}
  | ("{{contract.name.capitalized}}", "{{event.topic0}}") => {{event.event_type.full}}
{{/each}}
{{/each}}
  | (contractName, topic0) => UnknownEvent(contractName, topic0)->raise
  }


@genType
type chainId = int

type eventBatchQueueItem = {
  timestamp: int,
  chain: ChainMap.Chain.t,
  blockNumber: int,
  logIndex: int,
  event: event,
  //Default to false, if an event needs to
  //be reprocessed after it has loaded dynamic contracts
  //This gets set to true and does not try and reload events
  hasRegisteredDynamicContracts?: bool,
}
