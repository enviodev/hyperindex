open Types

let makeEventIdentifier = (
  eventItem: Internal.eventItem,
): Types.eventIdentifier => {
  let {event, blockNumber, timestamp} = eventItem
  {
    chainId: event.chainId,
    blockTimestamp: timestamp,
    blockNumber,
    logIndex: event.logIndex,
  }
}

let getEventId = (eventItem: Internal.eventItem) => {
  EventUtils.packEventIndex(
    ~blockNumber=eventItem.blockNumber,
    ~logIndex=eventItem.event.logIndex,
  )
}


let makeDynamicContractId = (~chainId, ~contractAddress) => {
  chainId->Belt.Int.toString ++ "-" ++ contractAddress->Address.toString
}

let makeDynamicContractRegisterFn = (
  ~contractName: Enums.ContractType.t,
  ~onRegister,
) => (contractAddress: Address.t) => {
  {{#if is_evm_ecosystem}} {{!-- TODO: Add validation for Fuel --}}
  // Even though it's the Address.t type on ReScript side, for TS side it's a string.
  // So we need to ensure that it's a valid checksummed address.
  let contractAddress = contractAddress->Address.Evm.fromAddressOrThrow
  {{/if}}

  onRegister(~contractAddress, ~contractName)
}

let makeWhereLoader = (
  loadLayer,
  ~entityMod,
  ~inMemoryStore,
  ~fieldName,
  ~fieldValueSchema,
  ~eventItem,
  ~groupLoad,
) => {
  Entities.eq: fieldValue => loadLayer->LoadLayer.loadByField(
    ~operator=Eq,
    ~entityMod,
    ~fieldName,
    ~fieldValueSchema,
    ~inMemoryStore,
    ~groupLoad,
    ~eventItem,
    ~fieldValue,
  ),
  gt: fieldValue => loadLayer->LoadLayer.loadByField(
    ~operator=Gt,
    ~entityMod,
    ~fieldName,
    ~fieldValueSchema,
    ~inMemoryStore,
    ~groupLoad,
    ~eventItem,
    ~fieldValue,
  )
}

let makeEntityHandlerContext = (
  type entity,
  ~eventIdentifier,
  ~inMemoryStore,
  ~entityMod: module(Entities.Entity with type t = entity),
  ~eventItem,
  ~getKey,
  ~loadLayer,
  ~shouldSaveHistory,
): entityHandlerContext<entity> => {
  {
    set: entity => {
      inMemoryStore->InMemoryStore.getInMemTable(~entityMod)->InMemoryTable.Entity.set(
        Set(entity)->Types.mkEntityUpdate(~eventIdentifier, ~entityId=getKey(entity)),
        ~shouldSaveHistory,
      )
    },
    deleteUnsafe: entityId => {
      inMemoryStore->InMemoryStore.getInMemTable(~entityMod)->InMemoryTable.Entity.set(
        Delete->Types.mkEntityUpdate(~eventIdentifier, ~entityId),
        ~shouldSaveHistory,
      )
    },
    get: entityId => loadLayer->LoadLayer.loadById(~entityMod, ~inMemoryStore, ~groupLoad=false, ~eventItem, ~entityId),
  }
}

let getContractRegisterContext = (~onRegister) => {
  //TODO only add contracts we've registered for the event in the config
  {{#each codegen_contracts as |contract| }}
  add{{contract.name.capitalized}}:  makeDynamicContractRegisterFn(~contractName={{contract.name.capitalized}}, ~onRegister),
  {{/each}}
}->(Utils.magic: Types.contractRegistrations => Internal.contractRegisterContext)

let getLoaderContext = (eventItem: Internal.eventItem, ~inMemoryStore: InMemoryStore.t, ~loadLayer: LoadLayer.t, ~groupLoad) => {
  {
    log: eventItem->Logging.getUserLogger,
    {{#each entities as | entity |}}
    {{entity.name.uncapitalized}}: {
      get: entityId => 
        loadLayer->LoadLayer.loadById(
          ~entityMod=module(Entities.{{entity.name.capitalized}}),
          ~inMemoryStore,
          ~groupLoad,
          ~eventItem,
          ~entityId
        ),
      getWhere: {
        {{#each entity.params as | param |}}{{#if param.is_queryable_field }}
        {{param.field_name.uncapitalized}}{{#if param.is_entity_field }}_id{{/if}}: loadLayer->makeWhereLoader(
          ~entityMod=module(Entities.{{entity.name.capitalized}}),
          ~inMemoryStore,
          ~fieldName="{{param.field_name.original}}{{#if param.is_entity_field }}_id{{/if}}",
          ~fieldValueSchema={{param.res_schema_code}},
          ~eventItem,
          ~groupLoad,
        ),
      {{/if}}{{/each}}
      },
    },
    {{/each}}
  }->(Utils.magic: Types.loaderContext => Internal.loaderContext)
}

let getHandlerContext = (
  eventItem: Internal.eventItem,
  ~inMemoryStore: InMemoryStore.t,
  ~loadLayer,
  ~shouldSaveHistory,
) => {
  let eventIdentifier = eventItem->makeEventIdentifier
  {
    log: eventItem->Logging.getUserLogger,
    {{#each entities as | entity |}}
    {{entity.name.uncapitalized}}: makeEntityHandlerContext(
      ~eventItem,
      ~eventIdentifier,
      ~inMemoryStore,
      ~entityMod=module(Entities.{{entity.name.capitalized}}),
      ~getKey=entity => entity.id,
      ~loadLayer,
      ~shouldSaveHistory,
    ),
    {{/each}}
  }->(Utils.magic: Types.handlerContext => Internal.handlerContext)
}

let getContractRegisterArgs = (eventItem: Internal.eventItem, ~onRegister): Internal.contractRegisterArgs => {
  event: eventItem.event,
  context: getContractRegisterContext(~onRegister),
}

let getLoaderArgs = (eventItem: Internal.eventItem, ~inMemoryStore, ~loadLayer, ~groupLoad): Internal.loaderArgs => {
  event: eventItem.event,
  context: eventItem->getLoaderContext(~inMemoryStore, ~loadLayer, ~groupLoad),
}

let getHandlerArgs = (
  eventItem: Internal.eventItem,
  ~inMemoryStore,
  ~loaderReturn,
  ~loadLayer,
  ~shouldSaveHistory,
): Internal.handlerArgs => {
  event: eventItem.event,
  context: eventItem->getHandlerContext(~inMemoryStore, ~loadLayer, ~shouldSaveHistory),
  loaderReturn,
}
