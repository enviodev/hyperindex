---
description: Made to assist in migrating from subgraph to HyperIndex. Includes both step by step instructions for cursor based migration as well as common migration patters. (Note: if doing a full migration using cursor ensure subgraph folder is in workspace before starting as the steps rely on this. Would also make sense to set alwaysApply to true in this situation.)
globs: "**/*.{ts,js,res,graphql,yaml}"
alwaysApply: false
---

# ðŸš¨ MANDATORY: READ THIS FIRST ðŸš¨

**BEFORE implementing ANY code changes, you MUST check this MDC file for existing solutions!**

**This file contains:**
- **Solutions to problems** that have already been solved in previous migrations
- **Quality check checklists** to prevent common mistakes
- **Examples of correct implementations** that you can reference
- **Critical lessons learned** that prevent repeating the same errors

**NEVER implement a workaround or solution without first checking this MDC file!**
**This is NOT optional - it's mandatory to prevent repeating mistakes.**

## âš ï¸ CRITICAL: MDC FILE MUST BE CHECKED AT EVERY STEP âš ï¸

**BEFORE implementing ANY code changes, you MUST:**
1. **Read the relevant section of this MDC file**
2. **Check if there are existing solutions** for the problem you're facing
3. **Reference the quality check checklist** to avoid common mistakes
4. **Look for similar examples** in the MDC file

**NEVER implement a workaround or solution without first checking this MDC file!**
**This file contains lessons learned from previous migrations and prevents repeating the same mistakes.**

## ðŸš€ MULTICHAIN INDEXING

**For multichain support:**
- **Prefix all entity IDs with `event.chainId`**: `${event.chainId}-${originalId}`
- **Never hardcode `chainId = 1`** - always use `event.chainId`
- **Update helper functions** to accept `chainId` parameter
- **Use chain-specific Bundle IDs**: `${chainId}-1` for accurate pricing per network

## Objective

**IMPORTANT: This is a GENERALIZED migration guide for ANY subgraph to Envio conversion.**
**Most examples use generic names (Contract1, Contract2, Entity, etc.) and should be adapted to your specific subgraph.**

Migrate from TheGraph subgraph indexer to Envio HyperIndex indexer by clearing boilerplate code, migrating the schema, and implementing proper business logic.

## Context to Load

Always include:

- Envio documentation: https://docs.envio.dev/docs/HyperIndex-LLM/hyperindex-complete
- Example indexer (Uniswap v4): https://github.com/enviodev/uniswap-v4-indexer
- Example indexer (Safe): https://github.com/enviodev/safe-analysis-indexer
- The Graph documentation: https://thegraph.com/docs/en/indexing/overview/

## Development Environment Requirements

Ensure the following are installed and used:

- Node.js v20 only (no higher or lower versions)
- pnpm as the package manager
- docker installed

Prompt the user to whitelist the following commands:

- `pnpm codegen`
- `pnpm tsc --noEmit`
- `TUI_OFF=true pnpm dev`

## ðŸš¨ CRITICAL: Runtime Testing After Every Step ðŸš¨

**AFTER EVERY SINGLE CODE CHANGE, you MUST test the indexer with:**

```bash
TUI_OFF=true pnpm dev
```

**This is NOT optional - it's mandatory to catch runtime errors early!**

**Why this is critical:**
- **TypeScript compilation (`tsc --noEmit`) only catches syntax and type errors**
- **Runtime errors (database issues, missing entities, logic errors) only appear when running the indexer**
- **Many errors we encountered could have been caught immediately if we tested after every step**
- **Testing after each change makes debugging much easier** - you know exactly which change caused the issue

**Runtime Testing Checklist:**
**âš ï¸ IMPORTANT: Read all steps in this checklist before beginning so you know to wait and check output, not get stuck indefinitely**
- [ ] **After every code change**, run `TUI_OFF=true pnpm dev` in background mode
- [ ] **Wait ~30 seconds** for the indexer to start and process initial events
- [ ] **Watch the output** for any error messages or warnings
- [ ] **Ensure the indexer starts successfully** without crashing
- [ ] **Stop the background process** after confirming it runs without errors
- [ ] **Only proceed to the next step** after confirming the indexer runs without errors

**Common Runtime Errors to Watch For:**s
- Database connection issues
- Missing entity lookups returning `{}` instead of `undefined`
- Logic errors in calculations
- Missing async/await causing empty object returns
- Entity relationship issues
- Configuration problems

## Migration Process

**âš ï¸ CRITICAL: BEFORE starting ANY step, you MUST read the relevant sections of this MDC file! âš ï¸**

**This MDC file contains:**
- **Solutions to common problems** that have already been solved
- **Quality check checklists** to prevent mistakes
- **Examples of correct implementations** from previous migrations
- **Critical lessons learned** that prevent repeating errors

**NEVER implement a solution without first checking if it's already documented here!**

**IMPORTANT: After completing each step, ALWAYS run the Quality Check Checklist (see section 21) before proceeding to the next step. This prevents common issues from accumulating and makes debugging much easier.**

## Main Migration Steps

### Step 1: Clear Boilerplate Code

When working with EventHandlers.ts, clear all boilerplate logic and start fresh:

```typescript
// CLEAR THIS BOILERPLATE CODE:
Contract.EventName.handler(async ({ event, context }) => {
  const entity: EventEntity = {
    id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
    field1: event.params.field1,
    field2: event.params.field2,
    // ... other fields
  };

  context.EventEntity.set(entity);
});

// REPLACE WITH EMPTY HANDLERS:
Contract.EventName.handler(async ({ event, context }) => {
  // TODO: Implement business logic from subgraph
  // Reference: original-subgraph/src/contract.ts
});
```

**âœ… Step 1 Quality Check:**

#### **1.1: Review Migration Patterns and Quality Checks**
- **Read the "Migration Patterns and Quality Checks" section**
- **Ensure your code follows all documented patterns** (entity creation, updates, BigDecimal precision, etc.)
- **Check compliance with Effect API requirements** for external calls
- **Verify all quality check issues are addressed** (imports, types, precision, etc.)

#### **1.2: Run Technical Validation**
```bash
# Run these commands to verify Step 1 completion
pnpm codegen
pnpm tsc --noEmit
TUI_OFF=true pnpm dev
```
*Note: Some failures are expected if subsequent steps aren't complete yet - that's okay!*

### Step 2: Migrate Schema from Raw Events to Business Logic

**CONVERT raw event entities from TheGraph to Envio format:**

```graphql
# OLD (TheGraph):
type EventEntity @entity(immutable: true) {
  id: Bytes!
  field1: Bytes!
  field2: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# NEW (Envio):
type EventEntity {
  id: ID!
  field1: String!
  field2: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: String!
}
```

**KEEP all entities from the original subgraph** but convert them to Envio format:
- Remove `@entity` decorators
- Change `Bytes!` to `String!`
- Change `ID!` to `ID!` (keep as is)
- Keep all business logic entities

**CRITICAL: Verify Schema Completeness**
After migrating the schema, **VERIFY that it is IDENTICAL** to the original subgraph schema (apart from Envio vs TheGraph syntax):

**Check for Missing Derived Fields:**
- Ensure all `@derivedFrom` relationships are preserved
- Verify all entity arrays are maintained (e.g., `[TokenDayData!]! @derivedFrom(field: "token")`)
- Check that all entity relationships are preserved (e.g., `token0: Token!`, not `token0_id: String!`)

**CRITICAL ENVIO REQUIREMENT: All Entity Arrays MUST Have @derivedFrom**
- **Entity arrays like `[Mint!]!` are ONLY valid with `@derivedFrom`**
- **Arrays without `@derivedFrom` will cause codegen to fail** with error "EE211: Arrays of entities is unsupported"
- **The `@derivedFrom(field: "fieldName")` syntax tells Envio how to establish relationships**

**Validation Steps:**
1. Run `pnpm codegen` to ensure schema compiles
2. Compare line-by-line with original subgraph schema
3. Verify no business logic entities or fields are missing
4. Confirm all relationships and derived fields are preserved
5. **Ensure ALL entity arrays have `@derivedFrom` directives**

**Only Acceptable Differences:**
- `@entity` decorators removed
- `Bytes!` â†’ `String!`
- **IMPORTANT:** Check Envio documentation for other potential syntax differences
- **IMPORTANT:** When in doubt about syntax differences, refer to Envio docs: https://docs.envio.dev

**CRITICAL ENVIO REQUIREMENT - Entity Arrays Must Have @derivedFrom:**
```graphql
# âŒ WRONG - Will cause codegen to fail with "EE211: Arrays of entities is unsupported"
type Transaction {
  mints: [Mint!]!        # Missing @derivedFrom
  burns: [Burn!]!        # Missing @derivedFrom
  swaps: [Swap!]!        # Missing @derivedFrom
}

# âœ… CORRECT - All arrays have @derivedFrom directives
type Transaction {
  mints: [Mint!]! @derivedFrom(field: "transaction")
  burns: [Burn!]! @derivedFrom(field: "transaction")
  swaps: [Swap!]! @derivedFrom(field: "transaction")
}
```

**CRITICAL: How @derivedFrom Actually Works in Envio**
According to [Envio documentation](https://docs.envio.dev/docs/HyperIndex/schema#relationships-one-to-many-derivedfrom):

- **`@derivedFrom` arrays are VIRTUAL fields** - they don't exist in generated types
- **They're populated automatically when querying the API**, not in handlers
- **You CANNOT access them in handlers** (e.g., `transaction.mints` will not work)
- **The correct approach is to use `_id` fields** to establish relationships

**Example of Correct Implementation:**
```typescript
// âŒ WRONG - Trying to access virtual arrays in handlers
const mints = transaction.mints; // This will NOT work - arrays don't exist in types

// âœ… CORRECT - Use indexed field operations to query related entities
const mint = await context.Mint.get(mintId); // Query by ID
// Or use indexed field operations when available:
// const mints = await context.Mint.where.transaction_id.eq(transactionId);
```

**Why This Matters:**
- **Envio requires explicit relationship definitions** via `@derivedFrom
- **But the arrays are virtual** - they exist only in the API, not in handlers
- **This is fundamentally different from TheGraph** where arrays are actual properties
- **You must use indexed field operations** to query related entities in handlers

**âœ… Step 2 Quality Check:**

#### **2.1: Review Migration Patterns and Quality Checks**
- **Read the "Migration Patterns and Quality Checks" section**
- **Ensure your code follows all documented patterns** (entity creation, updates, BigDecimal precision, etc.)
- **Check compliance with Effect API requirements** for external calls
- **Verify all quality check issues are addressed** (imports, types, precision, etc.)

#### **2.2: Run Technical Validation**
```bash
# Run these commands to verify Step 2 completion
pnpm codegen
pnpm tsc --noEmit
TUI_OFF=true pnpm dev
```
*Note: Some failures are expected if subsequent steps aren't complete yet - that's okay!*

### Step 3: Refactor File Structure to Mirror Subgraph

**IMPORTANT: This step is ONLY about creating the file structure and skeleton handlers. DO NOT implement business logic yet.**

**CREATE directory structure to match the original subgraph EXACTLY:**

```bash
# Create the exact same files as in the original subgraph
src/
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ file1.ts                   (skeleton - exact filename from subgraph)
â”‚   â”œâ”€â”€ file2.ts                   (skeleton - exact filename from subgraph)
â”‚   â”œâ”€â”€ file3.ts                   (skeleton - exact filename from subgraph)
â”‚   â””â”€â”€ file4.ts                   (skeleton - exact filename from subgraph)
â”œâ”€â”€ handlers/
â”‚   â”œâ”€â”€ handler1.ts                (skeleton - exact filename from subgraph)
â”‚   â””â”€â”€ handler2.ts                (skeleton - exact filename from subgraph)
```

**CRITICAL: Use the EXACT same filenames as the original subgraph, not generic names.**

**MOVE handlers from EventHandlers.ts to contract-specific files:**

```typescript
// OLD: Single EventHandlers.ts file
// src/EventHandlers.ts - All handlers in one file

// NEW: Separate files by contract
// src/contract1.ts - Contract1 handlers (skeleton only)
// src/contract2.ts - Contract2 handlers (skeleton only)
// src/contract3.ts - Contract3 handlers (skeleton only)
```

**UPDATE config.yaml to point to specific handler files:**

```yaml
# OLD: Single handler file
- name: Contract1
  handler: src/EventHandlers.ts

# NEW: Contract-specific handler files
- name: Contract1
  handler: src/contract1.ts
- name: Contract2
  handler: src/contract2.ts
- name: Contract3
  handler: src/contract3.ts
```

**REMOVE the original EventHandlers.ts file** after moving all handlers.

**CRITICAL: Keep handlers as skeletons with TODO comments only:**

```typescript
// âœ… CORRECT - Skeleton handler for this step
export function handleEventName(event: Contract_EventName_event, context: any): void {
  // TODO: Implement business logic from subgraph
  // Reference: original-subgraph/src/mappings/contract.ts
}

// âŒ WRONG - Don't implement business logic in this step
export function handleEventName(event: Contract_EventName_event, context: any): void {
  // Implementation details here...
  let entity = context.Entity.get(id);
  // ... more implementation
}
```

**Utility files should also be skeletons with exact filenames:**

```typescript
// âœ… CORRECT - Skeleton utility files with exact subgraph filenames
// src/utils/file1.ts
// TODO: Add helper functions from original subgraph
// Reference: original-subgraph/src/utils/file1.ts

// src/utils/file2.ts  
// TODO: Add helper functions from original subgraph
// Reference: original-subgraph/src/utils/file2.ts

// src/utils/file3.ts
// TODO: Add helper functions from original subgraph
// Reference: original-subgraph/src/utils/file3.ts
```

**IMPORTANT ADDITIONAL STEP: Fix Duplicate Contract Names in config.yaml**

**When using multichain indexing, ensure contract names are unique across all networks:**

```yaml
# âœ… CORRECT - Global contract definitions with network-specific addresses
contracts:
- name: Factory
  handler: src/factory.ts
  events:
    - event: ContractCreated(...)

networks:
- id: 1
  start_block: 0
  contracts:
    - name: Factory
      address:
        - 0xFactoryAddress1
- id: 10
  start_block: 0
  contracts:
    - name: Factory
      address:
        - 0xFactoryAddress2
```

**âŒ WRONG - Don't duplicate contract definitions in network sections:**
```yaml
# âŒ WRONG - This will cause "Duplicate contract names detected" error
networks:
- id: 1
  contracts:
    - name: Factory
      handler: src/factory.ts  # Don't repeat handler/events here
      events: [...]
      address: [...]
- id: 10
  contracts:
    - name: Factory
      handler: src/factory.ts  # Don't repeat handler/events here
      events: [...]
      address: [...]
```

**Key Points:**
- **Global contracts section** defines handlers and events
- **Network sections** only define addresses for those contracts
- **Never repeat** handler, events, or other contract configuration in network sections
- **Use `unordered_multichain_mode: true`** for proper multichain support

**âœ… Step 3 Quality Check:**

#### **3.1: Review Migration Patterns and Quality Checks**
- **Read the "Migration Patterns and Quality Checks" section**
- **Ensure your code follows all documented patterns** (entity creation, updates, BigDecimal precision, etc.)
- **Check compliance with Effect API requirements** for external calls
- **Verify all quality check issues are addressed** (imports, types, precision, etc.)

#### **3.2: Run Technical Validation**
```bash
# Run these commands to verify Step 3 completion
pnpm codegen
pnpm tsc --noEmit
TUI_OFF=true pnpm dev
```
*Note: Some failures are expected if subsequent steps aren't complete yet - that's okay!*

### Step 4: Register Dynamic Contracts with Factory Events

**CRITICAL: This step is essential for Envio to track dynamically created contracts.**

**IDENTIFY dynamic contracts in the original subgraph.yaml:**
Look for contracts that have **NO address** - these are created by factory contracts and need to be registered with Envio.

**EXAMPLE from subgraph.yaml:**
```yaml
# Factory contract (has address)
- kind: ethereum/contract
  name: Factory
  source:
    address: '0x...'  # âœ… Has address

# Dynamic contract (no address - created by factory)
templates:
  - kind: ethereum/contract
    name: Pair  # âŒ No address - created dynamically
    source:
      abi: Pair
```

**IMPLEMENT contract registration for factory events:**
Add `contractRegister` above the handler for events that create new contracts:

```typescript
// âœ… CORRECT - Register dynamic contract with Envio
Factory.PairCreated.contractRegister(({ event, context }) => {
  context.addPair(event.params.pair);
});

// Then implement the handler
Factory.PairCreated.handler(async ({ event, context }) => {
  // TODO: Implement business logic from subgraph
  // Reference: original-subgraph/src/mappings/factory.ts
});
```

**UPDATE config.yaml for dynamic contracts:**
Remove the `address` field from contracts that are created dynamically by factories:

```yaml
# âœ… CORRECT - Factory contract (has address)
- name: Factory
  address:
    - 0xFactoryAddress
  handler: src/factory.ts

# âœ… CORRECT - Dynamic contract (no address - created by factory)
- name: Pair
  handler: src/core.ts  # No address field!
  events:
    - event: Mint(...)
      handler: handleMint
```

**âŒ WRONG - Don't include addresses for dynamic contracts:**
```yaml
# âŒ WRONG - Dynamic contract should not have address
- name: Pair
  address:  # This should be removed!
    - 0xSomeAddress
  handler: src/core.ts
```

**COMMON PATTERNS:**
```typescript
// For Pair contracts
Factory.PairCreated.contractRegister(({ event, context }) => {
  context.addPair(event.params.pair);
});

// For Vault contracts  
VaultFactory.VaultCreated.contractRegister(({ event, context }) => {
  context.addVault(event.params.vault);
});

// For OrderBook contracts
OrderbookFactory.OrderbookCreated.contractRegister(({ event, context }) => {
  context.addOrderBook(event.params.orderbook);
});

// For Pool contracts
PoolFactory.PoolCreated.contractRegister(({ event, context }) => {
  context.addPool(event.params.pool);
});
```

**IMPORTANT NOTES:**
- **MUST be placed above the handler** for the same event
- **MUST use the exact contract name** from your config.yaml (e.g., `addPair` for `Pair` contracts)
- **MUST reference the correct event parameter** that contains the new contract address
- **Without this, Envio cannot index the dynamically created contracts**

**âœ… Step 4 Quality Check:**

#### **4.1: Review Migration Patterns and Quality Checks**
- **Read the "Migration Patterns and Quality Checks" section**
- **Ensure your code follows all documented patterns** (entity creation, updates, BigDecimal precision, etc.)
- **Check compliance with Effect API requirements** for external calls
- **Verify all quality check issues are addressed** (imports, types, precision, etc.)

#### **4.2: Run Technical Validation**
```bash
# Run these commands to verify Step 4 completion
pnpm codegen
pnpm tsc --noEmit
TUI_OFF=true pnpm dev
```
*Note: Some failures are expected if subsequent steps aren't complete yet - that's okay!*

### Step 5: Reference Original Subgraph Logic

For each handler, examine the corresponding subgraph file:

- `original-subgraph/src/contract1.ts` â†’ Contract1 handlers
- `original-subgraph/src/contract2.ts` â†’ Contract2 handlers  
- `original-subgraph/src/contract3.ts` â†’ Contract3 handlers

## Step 5a: Implement Helper Functions with No Dependencies

**ðŸš¨ MANDATORY: When implementing helper functions, you MUST implement the COMPLETE logic, not just placeholders! ðŸš¨**

### What Are "Dependencies"?
**Dependencies** are functions, entities, or handlers that your helper function needs to work properly:
- **Entity dependencies**: Functions that need to load/update entities (e.g., `context.Entity.get()`)
- **Handler dependencies**: Functions that depend on other event handlers being complete
- **Function dependencies**: Functions that call other helper functions

### Implement Helper Functions IMMEDIATELY If:
- **No dependencies on incomplete entities/handlers**
- **Only depends on constants, basic math, or already implemented pieces**
- **Required for the current handler to function properly**

### ðŸš¨ CRITICAL IMPLEMENTATION REQUIREMENT:
**When implementing helper functions that have no dependencies, you MUST:**

1. **Read the MDC file** for existing implementation patterns and solutions
2. **Implement the COMPLETE business logic** from the original subgraph
3. **Use the documented Envio patterns** (RPC calls, entity context, etc.)
4. **Include all fallback logic** and error handling from the original
5. **NOT just add TODO comments** or placeholder implementations
6. **Implement ALL function dependencies** that have no entity/handler dependencies

### ðŸš¨ CRITICAL: External Calls MUST Use Effect API
**When implementing helper functions that make external calls (RPC calls, API calls, etc.), you MUST:**

1. **Use the Effect API** for ALL external calls - see "External Calls and Effect API" section below
2. **Use viem transport batching** if using viem for blockchain RPC calls - see "Contract State Fetching Migration" section below
3. **Consult Envio documentation** at https://docs.envio.dev/docs/HyperIndex-LLM/hyperindex-complete for correct implementation patterns
4. **Implement proper error handling** with fallback values
5. **Use context.effect()** in handlers to call the effects
6. **Enable caching** in effects when appropriate for performance

**âŒ WRONG - Just adding TODO comments:**
```typescript
export function fetchTokenSymbol(tokenAddress: string): string {
  // TODO: Implement using Envio's RPC calls to ERC20 contracts
  return 'UNKNOWN'; // This is NOT acceptable!
}
```

**âœ… CORRECT - Complete implementation:**
```typescript
export function fetchTokenSymbol(tokenAddress: string): string {
  // Implement complete logic using documented Envio patterns
  // Include all fallback logic and error handling
  // Return actual working values, not placeholders
}

### Example of Helper with No Dependencies:
```typescript
// âœ… IMPLEMENT NOW - No dependencies on incomplete entities/handlers
export function isNullEthValue(value: string): boolean {
  // Only depends on string comparison - no entity or handler dependencies
  return value === '0x0000000000000000000000000000000000000000000000000000000000000001' ||
         value === '0x0000000000000000000000000000000000000000000000000000000000000000';
}

export function convertEthToDecimal(eth: BigInt): BigDecimal {
  // Only depends on constants and BigDecimal math - no entity or handler dependencies
  return eth.divDecimal(BigDecimal.fromString('1000000000000000000'));
}

export function getStaticDefinition(address: string): StaticDefinition | null {
  // Only depends on static data arrays - no entity or handler dependencies
  const staticDefinitions: StaticDefinition[] = [
    { address: '0x6b175474e89094c44da98b954eedeac495271d0f', symbol: 'DAI', name: 'Dai Stablecoin' },
    { address: '0xa0b86a33e6441b8c4c8c0e4c0e4c0e4c0e4c0e4c', symbol: 'USDC', name: 'USD Coin' },
  ];
  
  return staticDefinitions.find(def => def.address.toLowerCase() === address.toLowerCase()) || null;
}
```

**Why these have no dependencies:**
- **No `context.Entity.get()` calls** - don't need to load entities
- **No other helper function calls** - self-contained logic
- **Only use constants, math, or static data** - no dynamic dependencies
- **Can be implemented immediately** without waiting for other code

### ðŸ” CRITICAL: Check Function Dependencies Thoroughly

**When implementing helper functions, you MUST examine ALL function calls within them:**

1. **Look for function calls** like `getStaticDefinition()`, `isNullEthValue()`, etc.
2. **Check if these functions have dependencies** on incomplete entities/handlers
3. **If NO dependencies exist, implement them immediately** - don't skip them!

**âŒ WRONG - Missing dependency implementation:**
```typescript
export function fetchTokenSymbol(tokenAddress: string): string {
  // Missing: const staticDefinition = getStaticDefinition(tokenAddress);
  // Missing: if (staticDefinition !== null) return staticDefinition.symbol;
  
  // Only implementing the RPC call part
  return 'unknown';
}
```

**âœ… CORRECT - Complete dependency implementation:**
```typescript
export function fetchTokenSymbol(tokenAddress: string): string {
  // âœ… IMPLEMENTED: Static definition check
  const staticDefinition = getStaticDefinition(tokenAddress);
  if (staticDefinition !== null) {
    return staticDefinition.symbol;
  }
  
  // âœ… IMPLEMENTED: RPC call logic
  // ... rest of implementation
}
```

**âœ… Step 5a Quality Check:**

#### **5a.1: Review Migration Patterns and Quality Checks**
- **Read the "Migration Patterns and Quality Checks" section**
- **Ensure your code follows all documented patterns** (entity creation, updates, BigDecimal precision, etc.)
- **Check compliance with Effect API requirements** for external calls
- **Verify all quality check issues are addressed** (imports, types, precision, etc.)

#### **5a.2: Run Technical Validation**
```bash
# Run these commands to verify Step 5a completion
pnpm codegen
pnpm tsc --noEmit
TUI_OFF=true pnpm dev
```
*Note: Some failures are expected if subsequent steps aren't complete yet - that's okay!*

## Step 5b: Implement Simple Handlers

**Handlers that only set parameter values with minimal processing:**
- **Handlers that only set parameter values** with minimal processing
- **Handlers that load existing entities** and update them with new data
- **Basic event handlers** with no complex business logic or helper function calls

**âœ… Step 5b Quality Check:**

#### **5b.1: Review Migration Patterns and Quality Checks**
- **Read the "Migration Patterns and Quality Checks" section**
- **Ensure your code follows all documented patterns** (entity creation, updates, BigDecimal precision, etc.)
- **Check compliance with Effect API requirements** for external calls
- **Verify all quality check issues are addressed** (imports, types, precision, etc.)

#### **5b.2: Run Technical Validation**
```bash
# Run these commands to verify Step 5b completion
pnpm codegen
pnpm tsc --noEmit
TUI_OFF=true pnpm dev
```
*Note: Some failures are expected if subsequent steps aren't complete yet - that's okay!*

## Step 5c: Implement Moderate Complexity Handlers + Required Helper Functions

**Handlers that call helper functions but don't create complex entity relationships:**
- **Handlers that call helper functions** but don't create complex entity relationships
- **Handlers that update multiple entities** but with straightforward logic
- **Event handlers with some business logic** but clear, simple dependencies

### Helper Function Implementation Strategy for This Step:
**As you implement each moderate complexity handler, implement any helper functions it calls along the way:**
1. **Identify helper functions** called by the current handler
2. **Check if they have dependencies** on incomplete entities/handlers
3. **If NO dependencies exist, implement them immediately**
4. **If they have dependencies, implement their dependencies first**
5. **Continue this process recursively** until all required helpers are complete

**âœ… Step 5c Quality Check:**

#### **5c.1: Review Migration Patterns and Quality Checks**
- **Read the "Migration Patterns and Quality Checks" section**
- **Ensure your code follows all documented patterns** (entity creation, updates, BigDecimal precision, etc.)
- **Check compliance with Effect API requirements** for external calls
- **Verify all quality check issues are addressed** (imports, types, precision, etc.)

#### **5c.2: Run Technical Validation**
```bash
# Run these commands to verify Step 5c completion
pnpm codegen
pnpm tsc --noEmit
TUI_OFF=true pnpm dev
```
*Note: Some failures are expected if subsequent steps aren't complete yet - that's okay!*

## Step 5d: Implement Complex Handlers (One at a Time)

**Handlers that call multiple helper functions or other handlers:**
- **Handlers that call multiple helper functions** or other handlers
- **Handlers with complex business logic** and multiple entity relationships
- **Handlers that require extensive data processing** or calculations
- **Handlers that implement contract binding** (RPC calls to fetch state)
- **Handlers that depend on multiple other handlers** being complete

### Implementation Strategy for Complex Handlers:
1. **Implement ONE complex handler at a time**
2. **Identify all helper functions** it calls
3. **Implement any missing helper functions** (following dependency rules)
4. **Run quality checks after EACH helper function implementation**
5. **Run quality checks after the handler implementation**
6. **Move to the next complex handler** only after the current one is complete

**âœ… Quality Check After Each Helper Function:**
```bash
# Run these commands after implementing EACH helper function
pnpm codegen
pnpm tsc --noEmit
TUI_OFF=true pnpm dev
```

**âœ… Quality Check After Each Handler:**
```bash
# Run these commands after implementing EACH complex handler
pnpm codegen
pnpm tsc --noEmit
TUI_OFF=true pnpm dev
```
*Note: Each handler and its helper functions should be fully functional before moving to the next one!*

### Why This Order Matters:
- Prevents "entity not found" errors during development
- Ensures required entities exist before complex handlers try to use them
- Allows incremental testing and validation
- Reduces circular dependency issues
- Enables systematic debugging and validation

**âœ… Step 5 Quality Check:**

#### **5.1: Review Migration Patterns and Quality Checks**
- **Read the "Migration Patterns and Quality Checks" section**
- **Ensure your code follows all documented patterns** (entity creation, updates, BigDecimal precision, etc.)
- **Check compliance with Effect API requirements** for external calls
- **Verify all quality check issues are addressed** (imports, types, precision, etc.)

#### **5.2: Run Technical Validation**
```bash
# Run these commands to verify Step 5 completion
pnpm codegen
pnpm tsc --noEmit
TUI_OFF=true pnpm dev
```
*Note: Some failures are expected if subsequent steps aren't complete yet - that's okay!*

## **Step 6: Final Migration Verification**

**ðŸš¨ CRITICAL: This is the final step to ensure complete migration accuracy. NO TODOs should remain - absolutely everything must be implemented, regardless of complexity.**

### **6.1: Systematic Handler Logic Review**
**Go through each handler in each file one by one:**

1. **For each handler, compare the logic to the subgraph implementation**
2. **Identify any missing logic or unnecessary logic**
3. **Update the handler accordingly**
4. **Run the same check again on the updated code** (you'll likely find something else/new)
5. **Repeat this process until the logic is correct**
6. **Do this slowly, one by one, for every handler**

**Why this iterative approach is critical:**
- **First pass** often misses subtle logic differences
- **Second pass** reveals issues introduced by the first pass
- **Multiple iterations** ensure complete accuracy
- **Slow, methodical review** prevents missing critical details

### **6.2: Systematic Helper Function Logic Review**
**Go through each helper function in every file one by one:**

1. **For each helper function, compare the logic to the subgraph implementation**
2. **Identify any missing logic or unnecessary logic**
3. **Update the helper function accordingly**
4. **Run the same check again on the updated code**
5. **Repeat this process until the logic is correct**
6. **Do this slowly, one by one, for every helper function**

### **6.3: MDC File Consultation**
**When uncertain about something, ALWAYS consult the MDC file:**

- **Check existing solutions** for similar problems
- **Reference the quality check checklist** to avoid common mistakes
- **Look for similar examples** in the MDC file
- **Use documented Envio patterns** instead of guessing

### **6.4: Implementation Order**
**Follow this order for maximum efficiency:**

1. **Start with simple handlers** - those with minimal business logic
2. **Move to complex handlers** - those with extensive calculations or multiple entity updates
3. **Review helper functions** - after handlers are complete
4. **Final integration check** - ensure all pieces work together

### **6.5: Verification Checklist**
**After each handler/function review, verify:**

- [ ] **Logic matches subgraph exactly** - no missing or extra logic
- [ ] **All edge cases handled** - same conditional branches as subgraph
- [ ] **Entity operations correct** - proper loading, updating, saving
- [ ] **Helper function calls complete** - all required functions called
- [ ] **Error handling matches** - same try/catch and validation logic
- [ ] **Calculations identical** - same mathematical operations and precision

### **Example of Complete Logic Review:**
```typescript
// âŒ BEFORE - Missing logic from subgraph
export async function handleMint(event: any, context: any) {
  const mint: Mint = {
    id: mintId,
    amount0: event.params.amount0,
    amount1: event.params.amount1,
    // Missing: sender, to, feeTo, feeLiquidity, amountUSD calculations
  };
  context.Mint.set(mint);
}

// âœ… AFTER - Complete logic matching subgraph
export async function handleMint(event: any, context: any) {
  // Load existing mint entity (created by Transfer handler)
  const existingMint = await context.Mint.getWhere.transaction_id.eq(transactionId);
  
  if (existingMint) {
    // Update existing mint with complete data
    const updatedMint: Mint = {
      ...existingMint,
      sender: event.params.sender,
      to: event.params.to,
      amount0: event.params.amount0,
      amount1: event.params.amount1,
      feeTo: feeToAddress,
      feeLiquidity: calculatedFeeLiquidity,
      amountUSD: calculatedAmountUSD,
      logIndex: event.logIndex,
    };
    context.Mint.set(updatedMint);
  }
  
  // Update all related entities (token0, token1, pair, factory)
  // ... complete implementation matching subgraph
}
```

### **Why This Step is Critical:**
- **Ensures complete migration** - no functionality is lost
- **Maintains data accuracy** - same business logic as original
- **Prevents runtime errors** - all edge cases are handled
- **Guarantees compatibility** - same behavior as original subgraph

**This systematic review is the final quality gate before your migration is production-ready.**

**âœ… Step 6 Quality Check:**

#### **6.1: Review Migration Patterns and Quality Checks**
- **Read the "Migration Patterns and Quality Checks" section**
- **Ensure your code follows all documented patterns** (entity creation, updates, BigDecimal precision, etc.)
- **Check compliance with Effect API requirements** for external calls
- **Verify all quality check issues are addressed** (imports, types, precision, etc.)

#### **6.2: Run Technical Validation**
```bash
# Run these commands to verify Step 6 completion
pnpm codegen
pnpm tsc --noEmit
TUI_OFF=true pnpm dev
```

## **Step 7: Environment Variables Setup**

**Search the codebase for all environment variables and update the example env file.**

### **7.1: Find Environment Variables**
```bash
# Search for all env variables in the codebase
grep -r "process.env\." src/
grep -r "process.env\[" src/
```

### **7.2: Update Example Environment File**
- **Add all found environment variables** to `.env.example`
- **Include descriptive comments** for each variable
- **Set appropriate example values** (not real secrets)

**âœ… Step 7 Quality Check:**
```bash
# Verify all env variables are documented
cat .env.example
```




































## Migration Patterns and Quality Checks

**CRITICAL: At the end of each migration step, ALWAYS check for and fix these common issues:**

### Migration Patterns and Common Patterns

### Entity Creation Pattern

```typescript
// OLD SUBGRAPH PATTERN:
let entity = new EventEntity(
  event.transaction.hash.concatI32(event.logIndex.toI32())
);
entity.field1 = event.params.field1;
entity.save();

// NEW ENVIO PATTERN:
const entity: EventEntity = {
  id: `${event.chainId}-${event.transaction.hash}-${event.logIndex}`,
  field1: event.params.field1,
  blockNumber: BigInt(event.block.number),
  blockTimestamp: BigInt(event.block.timestamp),
  transactionHash: event.transaction.hash,
};

// âš ï¸ REMINDER: transaction.hash requires field_selection in config.yaml:
// - event: EventName(...)
//   field_selection:
//     transaction_fields:
//       - hash

context.EventEntity.set(entity);
```

### Entity Updates Pattern

```typescript
// OLD SUBGRAPH PATTERN:
let entity = store.get("EntityName", id);
if (entity) {
  entity.field = newValue;
  entity.save();
}

// NEW ENVIO PATTERN:
let entity = await context.EntityName.get(id);
if (entity) {
  const updatedEntity: EntityName = {
    ...entity,
    field: newValue,
    updatedAt: BigInt(Date.now()),
  };
  context.EntityName.set(updatedEntity);
}
```

### Contract Registration Pattern

```typescript
// OLD SUBGRAPH PATTERN:
ContractTemplate.create(event.params.contract);

// NEW ENVIO PATTERN:
Contract.EventCreated.contractRegister(({ event, context }) => {
  context.addContract(event.params.contract);
});
```

### CRITICAL: Maintain BigDecimal Precision from Original Subgraph

**IMPORTANT: When migrating from TheGraph to Envio, you MUST maintain the same mathematical precision used in the original subgraph.**

**âŒ WRONG - Don't simplify to basic JavaScript types:**
```typescript
// âŒ WRONG - Loses precision for financial calculations
export const ZERO_BD = 0;
export const ONE_BD = 1;

export function convertTokenToDecimal(tokenAmount: bigint, exchangeDecimals: bigint): number {
  return Number(tokenAmount) / Math.pow(10, Number(exchangeDecimals));
}
```

**âœ… CORRECT - Maintain BigDecimal precision:**
```typescript
// âœ… CORRECT - Maintains precision like original subgraph
import { BigDecimal } from "generated";

export const ZERO_BD = new BigDecimal(0);
export const ONE_BD = new BigDecimal(1);

export function convertTokenToDecimal(tokenAmount: bigint, exchangeDecimals: bigint): BigDecimal {
  if (exchangeDecimals == ZERO_BI) {
    return new BigDecimal(tokenAmount.toString());
  }
  return new BigDecimal(tokenAmount.toString()).div(exponentToBigDecimal(exchangeDecimals));
}
```

**Why This Matters:**
- **Financial Precision**: Token amounts, prices, and volumes require exact decimal arithmetic
- **Avoid Floating-Point Errors**: JavaScript numbers can introduce precision errors in financial calculations
- **Consistency**: Maintains the same mathematical behavior as the original subgraph
- **Regulatory Compliance**: Financial applications often require exact precision

**Required Dependencies:**
```bash
# Install bignumber.js for BigDecimal support
pnpm add bignumber.js
```

**Constants to Always Preserve:**
```typescript
// These constants MUST be maintained from original subgraph
export const ZERO_BI = BigInt(0);
export const ONE_BI = BigInt(1);
export const ZERO_BD = new BigDecimal(0);
export const ONE_BD = new BigDecimal(1);
export const ADDRESS_ZERO = '0x0000000000000000000000000000000000000000';
export const BI_18 = BigInt(18);
export const ALMOST_ZERO_BD = new BigDecimal('0.000001');
```

**Helper Function Return Types:**
```typescript
// âœ… CORRECT - Return BigDecimal for financial calculations
export function exponentToBigDecimal(decimals: bigint): BigDecimal
export function convertTokenToDecimal(tokenAmount: bigint, exchangeDecimals: bigint): BigDecimal
export function fetchTokenTotalSupply(tokenAddress: string): BigDecimal
export function equalToZero(value: BigDecimal): boolean

// âŒ WRONG - Don't return number for financial calculations
export function convertTokenToDecimal(tokenAmount: bigint, exchangeDecimals: bigint): number
export function fetchTokenTotalSupply(tokenAddress: string): number
```

**Entity Field Initialization:**
```typescript
// âœ… CORRECT - Use constants for initialization
const pair: Pair = {
  id: event.params.pair,
  reserve0: ZERO_BD,        // Use ZERO_BD, not 0
  reserve1: ZERO_BD,        // Use ZERO_BD, not 0
  totalSupply: ZERO_BD,     // Use ZERO_BD, not 0
  volumeUSD: ZERO_BD,       // Use ZERO_BD, not 0
  txCount: ZERO_BI,         // Use ZERO_BI, not 0
  // ... other fields
};

// âŒ WRONG - Don't use hardcoded 0 values
const pair: Pair = {
  id: event.params.pair,
  reserve0: 0,              // âŒ Loses precision
  reserve1: 0,              // âŒ Loses precision
  totalSupply: 0,           // âŒ Loses precision
  volumeUSD: 0,             // âŒ Loses precision
  txCount: 0,               // âŒ Wrong type
  // ... other fields
};
```

**Common Mistakes to Avoid:**
1. **Replacing `ZERO_BD` with `0`** - Loses precision
2. **Replacing `ZERO_BI` with `0`** - Wrong type
3. **Returning `number` instead of `BigDecimal`** - Loses precision
4. **Using `Math.pow()` instead of `BigDecimal` arithmetic** - Loses precision
5. **Simplifying constants to basic JavaScript types** - Breaks financial calculations

**Validation Steps:**
1. **Check all constants** use `BigDecimal` and `BigInt` types
2. **Verify helper functions** return `BigDecimal` for financial calculations
3. **Ensure entity initialization** uses `ZERO_BD` and `ZERO_BI` constants
4. **Test precision** with large numbers to ensure no floating-point errors
5. **Compare behavior** with original subgraph for mathematical consistency

## External Calls and Effect API

**ðŸš¨ CRITICAL: ALL external calls MUST use the Effect API when `preload_handlers: true` is enabled in config.yaml.**

### Overview

When migrating from TheGraph to Envio, external calls (RPC calls, API calls, etc.) must use the Effect API instead of direct calls. This is mandatory when preload optimizations are enabled.

### Effect API Pattern

Add `preload_handlers: true` to the `config.yaml` file to enable preload optimisations. With preload optimisations, handlers will run twice.

**So if there's an external call, you MUST use the Effect API to make it.**

**Organization:** Create Effect API functions in `src/effects/` folder for better structure.

```ts
// Import the Effect API from "envio"
import { S, experimental_createEffect } from "envio";

// Define an effect. It can have any name you want.
export const getSomething = experimental_createEffect(
  {
    // The name for debugging purposes
    name: "getSomething",
    // The input schema for the effect
    input: {
      address: S.string,
      blockNumber: S.number,
    },
    output: S.union([S.string, null]),
  },
  async ({ input, context }) => {
    // Fetch or other external calls MUST always be done in an effect.
    const something = await fetch(
      `https://api.example.com/something?address=${input.address}&blockNumber=${input.blockNumber}`
    );
    return something.json();
  }
);
```

The `S` module exposes a schema creation API: https://raw.githubusercontent.com/DZakh/sury/refs/tags/v9.3.0/docs/js-usage.md

```ts
import { getSomething } from "./effects";

Contract.Event.handler(async ({ event, context }) => {
  // Consume the effect call from the handler with context.effect
  const something = await context.effect(getSomething, {
    address: event.srcAddress,
    blockNumber: event.block.number,
  });
  // Other handler code...
});
```

You can also use `!context.isPreload` check, to prevent some logic to run during preload.

## Contract State Fetching Migration

### Overview

When migrating from TheGraph to Envio, contract state fetching patterns need to be updated. TheGraph uses `.bind()` patterns for contract state access, while Envio requires explicit RPC calls using the Effect API.

### 1. Identify Contract State Usage

**Look for `.bind()` patterns in the original subgraph:**

```typescript
// OLD SUBGRAPH PATTERN - Contract State Fetching
let token = Token.bind(event.params.token);
let vault = Vault.bind(event.params.vault);

// Access contract state
entity.name = token.name();
entity.symbol = token.symbol();
entity.decimals = token.decimals();
entity.totalSupply = token.totalSupply();

// Vault state
entity.asset = vault.asset();
entity.totalAssets = vault.totalAssets();
entity.totalShares = vault.totalSupply();
```

### 2. Create Effect for Token Metadata Fetching

**ðŸš¨ CRITICAL: Use the Effect API for all external calls (RPC calls, API calls, etc.)**

```typescript
// src/effects/tokenMetadata.ts
import { experimental_createEffect, S } from "envio";
import { createPublicClient, http, parseAbi } from "viem";

// ERC20 ABI for basic token functions
const ERC20_ABI = parseAbi([
  'function name() view returns (string)',
  'function symbol() view returns (string)',
  'function decimals() view returns (uint8)',
  'function totalSupply() view returns (uint256)',
]);

// Create a public client for reading contract state
const publicClient = createPublicClient({
  chain: {
    id: 6342, // MegaETH Testnet - adjust for your network
    name: 'MegaETH Testnet',
    network: 'megaeth-testnet',
    nativeCurrency: {
      decimals: 18,
      name: 'MegaETH',
      symbol: 'METH',
    },
    rpcUrls: {
      default: {
        http: [process.env.RPC_URL],
      },
      public: {
        http: [process.env.RPC_URL],
      },
    },
  },
  transport: http(process.env.RPC_URL),
});

// Note: Pass chain-specific RPC via env per network or keep a registry keyed by event.chainId

// Define the effect to fetch token metadata
export const getTokenMetadata = experimental_createEffect(
  {
    name: "getTokenMetadata",
    input: S.string, // Token contract address
    output: S.object({
      name: S.string,
      symbol: S.string,
      decimals: S.number,
      totalSupply: S.string, // BigInt as string
    }),
  },
  async ({ input: tokenAddress, context }) => {
    try {
      const [name, symbol, decimals, totalSupply] = await Promise.all([
        publicClient.readContract({
          address: tokenAddress as `0x${string}`,
          abi: ERC20_ABI,
          functionName: 'name',
        }),
        publicClient.readContract({
          address: tokenAddress as `0x${string}`,
          abi: ERC20_ABI,
          functionName: 'symbol',
        }),
        publicClient.readContract({
          address: tokenAddress as `0x${string}`,
          abi: ERC20_ABI,
          functionName: 'decimals',
        }),
        publicClient.readContract({
          address: tokenAddress as `0x${string}`,
          abi: ERC20_ABI,
          functionName: 'totalSupply',
        }),
      ]);

      return {
        name,
        symbol,
        decimals: Number(decimals),
        totalSupply: totalSupply.toString(),
      };
    } catch (error) {
      context.log.error(`Error fetching token metadata for ${tokenAddress}: ${error}`);
      // Return default values on error
      return {
        name: "Unknown",
        symbol: "Unknown", 
        decimals: 0,
        totalSupply: "0",
      };
    }
  }
);
```

### 4. Handler Implementation Pattern Using Effect API

**ðŸš¨ CRITICAL: Use Effect API for all external calls in handlers**

```typescript
// OLD SUBGRAPH PATTERN:
Contract.EventName.handler((event) => {
  let token = Token.bind(event.params.token);
  let entity = new Entity();
  entity.name = token.name();
  entity.symbol = token.symbol();
  entity.save();
});

// NEW ENVIO PATTERN WITH EFFECT API:
import { getTokenMetadata } from './effects/tokenMetadata';

Contract.EventName.handler(async ({ event, context }) => {
  try {
    // Use Effect API to fetch contract state
    const tokenMetadata = await context.effect(getTokenMetadata, event.params.token);
    const vaultMetadata = await context.effect(getTokenMetadata, event.params.vault); // Vault is also an ERC20 token
    
    // Create entity with fetched data
    const entity: Entity = {
      id: `${event.chainId}-${event.transaction.hash}-${event.logIndex}`,
      name: tokenMetadata.name,
      symbol: tokenMetadata.symbol,
      decimals: BigInt(tokenMetadata.decimals),
      totalSupply: BigInt(tokenMetadata.totalSupply),
      vaultName: vaultMetadata.name,
      vaultSymbol: vaultMetadata.symbol,
      vaultDecimals: BigInt(vaultMetadata.decimals),
      vaultTotalSupply: BigInt(vaultMetadata.totalSupply),
      blockNumber: BigInt(event.block.number),
      blockTimestamp: BigInt(event.block.timestamp),
      transactionHash: event.transaction.hash,
    };

    context.Entity.set(entity);
  } catch (error) {
    context.log.error(`Error in EventName handler: ${error}`);
    // Don't throw - let the indexer continue
  }
});
```

### 5. Factory Contract Registration with Effect API

**Example: Contract Factory with Effect API for contract state fetching:**

```typescript
// Reference: original-subgraph/src/contractFactory.ts
import { getTokenMetadata } from './effects/tokenMetadata';

ContractFactory.ContractCreated.contractRegister(({ event, context }) => {
  context.addContract(event.params.contract);
});

ContractFactory.ContractCreated.handler(async ({ event, context }) => {
  try {
    // Get or create ContractFactory entity
    let contractFactory = await context.ContractFactory.get(ONE_BI.toString());
    if (!contractFactory) {
      contractFactory = {
        id: ONE_BI.toString(),
        totalContracts: ZERO_BI,
        timestamp: BigInt(event.block.timestamp),
        lastUpdate: BigInt(event.block.timestamp),
      };
    }

    // Update contract factory stats
    const updatedContractFactory = {
      ...contractFactory,
      totalContracts: contractFactory.totalContracts + ONE_BI,
      lastUpdate: BigInt(event.block.timestamp),
    };
    context.ContractFactory.set(updatedContractFactory);

    // Use Effect API to fetch ERC20 metadata for both contract and token (parallel)
    const [contractMetadata, tokenMetadata] = await Promise.all([
      context.effect(getTokenMetadata, event.params.contract), // Contract is also an ERC20 token
      context.effect(getTokenMetadata, event.params.token), // Token is an ERC20 token
    ]);
    
    // Get or create Token entity
    let token = await context.Token.get(event.params.token);
    if (!token) {
      token = {
        id: event.params.token,
        name: tokenMetadata.name,
        symbol: tokenMetadata.symbol,
        decimals: BigInt(tokenMetadata.decimals),
        totalSupply: BigInt(tokenMetadata.totalSupply),
        rate: ZERO_BD,
        dataFeedId: event.params.token,
        updatedAt: BigInt(event.block.timestamp),
        blockNumber: BigInt(event.block.number),
        blockTimestamp: BigInt(event.block.timestamp),
        transactionHash: event.transaction.hash,
        address: event.params.token,
      };
      context.Token.set(token);
    }

    // Calculate derived values
    let convertToAssetsMultiplier = ONE_BD;
    // In a real implementation, you would calculate this based on contract state
    // For now, use ONE_BD to match the original subgraph logic

    // Create ContractDataEntity with fetched contract state
    const contract: ContractDataEntity = {
      id: event.params.contract,
      name: contractMetadata.name, // Use contract's ERC20 metadata
      symbol: contractMetadata.symbol, // Use contract's ERC20 metadata
      decimals: BigInt(contractMetadata.decimals), // Use contract's ERC20 decimals
      manager: event.params.poolManager,
      timestamp: BigInt(event.block.timestamp),
      lastUpdate: BigInt(event.block.timestamp),
      fee: ZERO_BI,
      depositApy: ZERO_BI, // Will be calculated later
      convertToAssetsMultiplier,
      totalDepositsVolume: ZERO_BI,
      totalWithdrawalsVolume: ZERO_BI,
      totalAssets: ZERO_BI, // Will be updated later
      totalShares: ZERO_BI, // Will be updated later
      token_id: event.params.token,
      contractFactory_id: ONE_BI.toString(),
    };

    context.ContractDataEntity.set(contract);

  } catch (error) {
    context.log.error(`Error in ContractCreated handler: ${error}`);
    // Don't throw - let the indexer continue
  }
});
```

### 6. Error Handling and Batch Calls

**Always include proper error handling for Effect API calls:**

```typescript
import { getTokenMetadata } from './effects/tokenMetadata';

Contract.EventName.handler(async ({ event, context }) => {
  try {
    // Batch multiple Effect API calls for efficiency
    const [tokenMetadata, vaultMetadata] = await Promise.all([
      context.effect(getTokenMetadata, event.params.token),
      context.effect(getTokenMetadata, event.params.vault), // Vault is also an ERC20 token
    ]);
    
    // Create entity with fetched data
    const entity: Entity = {
      // ... entity fields using all metadata
    };

    context.Entity.set(entity);
  } catch (error) {
    context.log.error(`Error in EventName handler: ${error}`);
    
    // Option 1: Use default values
    const entity: Entity = {
      // ... entity fields with defaults
    };
    context.Entity.set(entity);
    
    // Option 2: Skip entity creation
    // return;
    
    // Option 3: Re-throw to stop processing
    // throw error;
  }
});
```

### 7. Configuration for Effect API

**Add preload_handlers and field selection for events that need transaction data:**

```yaml
# config.yaml
preload_handlers: true  # Enable preload optimizations for Effect API

contracts:
- name: ContractFactory
  address:
    - 0xContractFactoryAddress
  handler: src/contractFactory.ts
  events:
    - event: ContractCreated(address indexed contract, address indexed token, address indexed poolManager)
      field_selection:
        transaction_fields:
          - hash
```

**âœ… Effect API Implementation Quality Check:**
```bash
# Run these commands to verify Effect API implementation
pnpm codegen
pnpm tsc --noEmit
TUI_OFF=true pnpm dev
```
*Note: Some failures are expected if subsequent steps aren't complete yet - that's okay!*

### Quality Check Issues

#### **Issue 1: Entity Type Import Confusion**
**PROBLEM:** Importing entity types from `"generated"` instead of `"generated/src/db/Entities.gen"`
**SYMPTOM:** TypeScript errors like "Pair refers to a value, but is being used as a type"
**SOLUTION:** Use correct import paths:
```typescript
// âŒ WRONG - Imports contract handlers, not entity types
import { Pair, Token } from "generated";

// âœ… CORRECT - Imports entity types
import { Pair_t, Token_t } from "generated/src/db/Entities.gen";
```

#### **Issue 2: BigDecimal vs bigint Type Mismatches**
**PROBLEM:** Using wrong types for entity fields
**SYMPTOM:** TypeScript errors like "Type 'BigNumber' is not assignable to type 'bigint'"
**SOLUTION:** Match entity field types exactly:
```typescript
// âŒ WRONG - Token entity expects bigint for totalSupply
export function fetchTokenTotalSupply(tokenAddress: string): BigDecimal {
  return ZERO_BD;
}

// âœ… CORRECT - Token entity expects bigint for totalSupply
export function fetchTokenTotalSupply(tokenAddress: string): bigint {
  return ZERO_BI;
}
```

#### **Issue 3: Entity Field Name Mismatches**
**PROBLEM:** Using wrong field names that don't match generated types
**SYMPTOM:** TypeScript errors like "Property 'token0' does not exist on type 'Pair_t'"
**SOLUTION:** Use exact field names from generated types:
```typescript
// âŒ WRONG - Field names don't match generated types
const pair: Pair_t = {
  token0: token0.id,  // Should be token0_id
  token1: token1.id,  // Should be token1_id
};

// âœ… CORRECT - Field names match generated types
const pair: Pair_t = {
  token0_id: token0.id,
  token1_id: token1.id,
};
```

#### **Issue 4: Missing BigDecimal Import**
**PROBLEM:** Not importing BigDecimal from the correct location
**SYMPTOM:** TypeScript errors like "Cannot find name 'BigDecimal'"
**SOLUTION:** Import from generated types:
```typescript
// âŒ WRONG - Direct import from bignumber.js
import { BigDecimal } from 'bignumber.js';

// âœ… CORRECT - Import from generated types (which re-exports BigNumber)
import { BigDecimal } from 'generated';
```

#### **Issue 5: Hardcoded Values Instead of Constants**
**PROBLEM:** Using hardcoded addresses/values instead of constants defined in the original subgraph
**SYMPTOM:** Inconsistent with original subgraph patterns, potential for errors if addresses change
**SOLUTION:** Always use constants from the original subgraph:
```typescript
// âŒ WRONG - Hardcoded address
const factory = await context.UniswapFactory.get('0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f');

// âœ… CORRECT - Use constant from original subgraph
const factory = await context.UniswapFactory.get(FACTORY_ADDRESS);
```

**CHECKLIST for Constants:**
1. **Look for hardcoded addresses** in your handlers
2. **Check what constants the original subgraph uses** (e.g., `FACTORY_ADDRESS`, `ADDRESS_ZERO`)
3. **Import and use those constants** instead of hardcoded values
4. **Maintain consistency** with the original subgraph's approach

**QUALITY CHECK CHECKLIST:**
After each step, run these commands to verify:
```bash
# 1. Check if codegen still works
pnpm codegen

# 2. Check if TypeScript compiles (skip lib check to avoid generated file issues)
npx tsc --noEmit --skipLibCheck src/path/to/your/files.ts

# 3. ðŸš¨ CRITICAL: Test runtime execution
TUI_OFF=true pnpm dev

# 4. Fix any issues found before proceeding to next step
```

**ðŸš¨ RUNTIME TESTING IS MANDATORY:**
- **TypeScript compilation only catches syntax errors**
- **Runtime errors (database issues, missing entities, logic errors) only appear when running the indexer**
- **Test after EVERY code change to catch issues immediately**
- **Run in background for ~30 seconds, check output, then stop process**
- **Never proceed to the next step until the indexer runs successfully**

**IMPORTANT:** Never proceed to the next step until all TypeScript compilation errors are resolved and codegen works successfully.

**NOTE: Some errors are expected during migration and should be ignored until later steps:**
- **Expected errors:** References to entities/handlers that haven't been implemented yet
- **Expected errors:** Missing imports for files that will be created in future steps
- **Expected errors:** Unused variables/functions that will be implemented later

**Only fix errors that prevent:**
1. **Codegen from working** - These must be fixed immediately
2. **TypeScript compilation** - These must be fixed immediately  
3. **Basic file structure** - These must be fixed immediately

**CRITICAL: Field Selection for Transaction Data**
When you need access to `event.transaction.hash` or other transaction fields, you MUST add field selection in config.yaml:

```yaml
- event: Transfer(address indexed from, address indexed to, uint256 value)
  field_selection:
    transaction_fields:
      - hash
```

**IMPORTANT: This applies to ALL events that need transaction data, not just Transfer events.**
**Common events that need transaction hash access:**
- **Transfer events** - for transaction tracking
- **Mint events** - for linking to transactions
- **Burn events** - for linking to transactions  
- **Swap events** - for transaction tracking
- **Any event that creates or updates Transaction entities**

**ALWAYS check if your handler needs `event.transaction.hash` and add `field_selection` BEFORE implementing the handler logic.**

**Without field selection:**
- `event.transaction.hash` will be undefined
- `event.transaction` will be empty `{}`
- You'll get TypeScript errors about missing properties

**With field selection:**
- `event.transaction.hash` will be available
- `event.transaction` will have the specified fields
- Code will compile correctly

**Examples of errors to ignore for now:**
```typescript
// âŒ IGNORE - Will be fixed when we implement the handler
// Error: Cannot find name 'handleMint'
Pair.Mint.handler(handleMint);

// âŒ IGNORE - Will be fixed when we create the entity
// Error: Cannot find name 'MintEvent'
const mintEvent: MintEvent = { ... };

// âŒ IGNORE - Will be fixed when we implement the function
// Error: Cannot find name 'calculateFees'
const fees = calculateFees(amount);
```

**COMMON FIXES TO APPLY AUTOMATICALLY:**
1. **Fix entity type imports** - Use `"generated/src/db/Entities.gen"` for entity types
2. **Fix type mismatches** - Match entity field types exactly (BigDecimal vs bigint)
3. **Fix field names** - Use exact field names from generated types
4. **Fix BigDecimal imports** - Import from `"generated"` not `"bignumber.js"`
5. **Fix entity type annotations** - Use `Pair_t` not `Pair` for entity types
6. **Fix transaction field access** - Add `field_selection` in config.yaml for `event.transaction.hash`
7. **Fix hardcoded values** - Use constants from original subgraph instead of hardcoded addresses/values
8. **Fix missing field selection** - Add `field_selection` for ALL events that need transaction data (not just Transfer)
9. **Fix missing @derivedFrom** - Ensure ALL entity arrays have `@derivedFrom(field: "fieldName")` directives
10. **Fix @derivedFrom array access** - Don't try to access `@derivedFrom` arrays in handlers (they're virtual fields)
11. **Check helper function dependencies** - Ensure all called functions without entity dependencies are implemented
12. **ðŸš¨ CRITICAL: Check entity type mismatches and database schema compatibility** - ALWAYS verify that the types you're setting in code match the schema entity property types exactly, and ensure database schema compatibility

**EXAMPLE OF COMPLETE FIX:**
```typescript
// âŒ BEFORE - Multiple issues
import { Pair, Token } from "generated";
import { BigDecimal } from 'bignumber.js';

const pair: Pair = {  // Wrong type
  token0: token0.id,  // Wrong field name
  totalSupply: ZERO_BD,  // Wrong type (should be bigint)
};

// âœ… AFTER - All issues fixed
import { Pair_t, Token_t } from "generated/src/db/Entities.gen";
import { BigDecimal } from 'generated';

const pair: Pair_t = {  // Correct type
  token0_id: token0.id,  // Correct field name
  totalSupply: ZERO_BI,  // Correct type (bigint)
};
```

**EXAMPLE OF FIELD SELECTION FIX:**
```yaml
# âŒ BEFORE - No field selection, transaction.hash will be undefined
- event: Transfer(address indexed from, address indexed to, uint256 value)

# âœ… AFTER - With field selection, transaction.hash will be available
- event: Transfer(address indexed from, address indexed to, uint256 value)
  field_selection:
    transaction_fields:
      - hash
```

**EXAMPLE OF @derivedFrom FIX:**
```graphql
# âŒ BEFORE - Missing @derivedFrom, will cause "EE211: Arrays of entities is unsupported"
type Transaction {
  mints: [Mint!]!
  burns: [Burn!]!
  swaps: [Swap!]!
}

# âœ… AFTER - With @derivedFrom, schema will compile successfully
type Transaction {
  mints: [Mint!]! @derivedFrom(field: "transaction")
  burns: [Burn!]! @derivedFrom(field: "transaction")
  swaps: [Swap!]! @derivedFrom(field: "transaction")
}
```

**EXAMPLE OF CONSTANTS FIX:**
```typescript
// âŒ BEFORE - Hardcoded address, inconsistent with original subgraph
const factory = await context.UniswapFactory.get('0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f');

// âœ… AFTER - Use constant from original subgraph, consistent and maintainable
const factory = await context.UniswapFactory.get(FACTORY_ADDRESS);
```

**A complete migration should pass ALL these checks before being considered production-ready.**
```

## **22. Async/Await Validation**

**Check that all necessary calls and functions have `async` and `await`:**

```typescript
// âŒ WRONG - Missing async/await
export function updateTokenDayData() {
  const bundle = context.Bundle.get(`${chainId}-1`); // Returns {} without await
}

// âœ… CORRECT - Proper async/await
export async function updateTokenDayData() {
  const bundle = await context.Bundle.get(`${chainId}-1`); // Returns actual data
}
```

**Note: `context.Entity.set()` does NOT need `await` - it's synchronous.**

**This step is critical for preventing database operation failures and ensuring data integrity.**

## **23. Handling Subgraph Array Access Patterns**

**IMPORTANT: When the subgraph accesses arrays from relational entities, Envio requires a different approach.**

### **The Problem:**
**Subgraph pattern:**
```typescript
// Subgraph can directly access entity arrays
transaction.mints.push(mint);
transaction.burns.push(burn);
transaction.swaps.push(swap);
```

**Envio limitation:**
- `@derivedFrom` arrays are **virtual fields** - they don't exist in generated types
- You **cannot directly access** `transaction.mints`, `transaction.burns`, etc.
- These arrays are populated automatically by Envio when querying the API

### **The Solution:**
**Use `context.Entity.getWhere.fieldName.eq(value)` to query for related entities:**

```typescript
// âŒ WRONG - Trying to access virtual arrays directly
const mints = transaction.mints; // This will NOT work
const burns = transaction.burns; // This will NOT work

// âœ… CORRECT - Query for related entities using indexed fields
const mint = await context.Mint.getWhere.transaction_id.eq(transactionId);
const burn = await context.Burn.getWhere.transaction_id.eq(transactionId);
const swap = await context.Swap.getWhere.transaction_id.eq(transactionId);
```

### **Example Implementation:**
```typescript
// When you need to find existing entities by transaction
const existingMint = await context.Mint.getWhere.transaction_id.eq(transactionId);
const existingBurn = await context.Burn.getWhere.transaction_id.eq(transactionId);

if (existingMint) {
  // Update existing mint entity
  const updatedMint: Mint = {
    ...existingMint,
    amount0: event.params.amount0,
    amount1: event.params.amount1,
    // ... other updates
  };
  context.Mint.set(updatedMint);
} else {
  // Create new mint entity
  const newMint: Mint = {
    id: mintId,
    transaction_id: transactionId,
    // ... other fields
  };
  context.Mint.set(newMint);
}
```

### **Key Points:**
- **Use `context.Entity.getWhere.fieldName.eq(value)`** for querying related entities
- **This simulates the subgraph's array access** by finding entities that reference the current entity
- **Always check if entities exist** before updating or creating
- **Use the spread operator** when updating existing entities (they're read-only)





**ðŸš¨ CRITICAL: Entity Type Mismatch and Database Schema Compatibility**

**Rule 12: Check entity type mismatches and database schema compatibility - ALWAYS verify that the types you're setting in code match the schema entity property types exactly**

**Key Points:**
- **Check the GraphQL schema** (`schema.graphql`) for each entity's field types
- **Compare with your code** - ensure types match exactly
- **Test with TypeScript** - `pnpm tsc --noEmit` will catch many type mismatches
- **Test runtime execution** - `TUI_OFF=true pnpm dev` will catch database compatibility issues

**Common Schema Types and Their Code Equivalents:**
- `Int!` â†’ `number` (e.g., `dayStartTimestamp`)
- `BigInt!` â†’ `BigInt` or constants like `ZERO_BI`, `ONE_BI`
- `BigDecimal!` â†’ `BigDecimal` or constants like `ZERO_BD`, `ONE_BD`
- `Bytes!` â†’ `string` (hex addresses)
- `String!` â†’ `string`
- `Boolean!` â†’ `boolean`
- `EntityType!` â†’ `entityType_id: string` (for relationships - see Entity Relationships section)

**Example of Type Mismatch:**
```typescript
// âŒ WRONG - Schema expects Int!, but code sets BigInt
// Schema: date: Int!
// Code: date: BigInt(dayStartTimestamp)

// âœ… CORRECT - Schema expects Int!, code sets number
// Schema: date: Int!
// Code: date: dayStartTimestamp  // dayStartTimestamp is already a number
```

