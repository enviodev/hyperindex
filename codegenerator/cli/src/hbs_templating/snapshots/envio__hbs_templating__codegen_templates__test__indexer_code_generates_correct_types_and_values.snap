---
source: cli/src/hbs_templating/codegen_templates.rs
expression: project_template.indexer_code
---
module Enums = {
module Status = {
  @genType
  type t =
    | @as("ACTIVE") ACTIVE
    | @as("INACTIVE") INACTIVE

  let name = "Status"
  let variants = [
    ACTIVE,
    INACTIVE,
  ]
  let config = Table.makeEnumConfig(~name, ~variants)
}

let allEnums: array<Table.enumConfig<Table.enum>> = ([
  Status.config->Table.fromGenericEnumConfig,
])
}

module Entities = {
open Table
type id = string

type internalEntity = Internal.entity
module type Entity = {
  type t
  let index: int
  let name: string
  let schema: S.t<t>
  let rowsSchema: S.t<array<t>>
  let table: Table.table
}
external entityModToInternal: module(Entity with type t = 'a) => Internal.entityConfig = "%identity"
external entityModsToInternal: array<module(Entity)> => array<Internal.entityConfig> = "%identity"
external entitiesToInternal: array<'a> => array<Internal.entity> = "%identity"

@get
external getEntityId: internalEntity => string = "id"

// Use InMemoryTable.Entity.getEntityIdUnsafe instead of duplicating the logic
let getEntityIdUnsafe = InMemoryTable.Entity.getEntityIdUnsafe

//shorthand for punning
let isPrimaryKey = true
let isNullable = true
let isArray = true
let isIndex = true

module EmptyEntity = {
  let name = "EmptyEntity"
  let index = 0
  @genType
  type t = {id: id, emptyField: id, status: Enums.Status.t, optionalStatus: option<Enums.Status.t>, related_id: id, optionalRelated_id: option<id>, tags: array<string>, optionalTags: option<array<string>>}

  let schema = S.object((s): t => {id: s.field("id", S.string), emptyField: s.field("emptyField", S.string), status: s.field("status", Enums.Status.config.schema), optionalStatus: s.field("optionalStatus", S.null(Enums.Status.config.schema)), related_id: s.field("related_id", S.string), optionalRelated_id: s.field("optionalRelated_id", S.null(S.string)), tags: s.field("tags", S.array(S.string)), optionalTags: s.field("optionalTags", S.null(S.array(S.string)))})

  let rowsSchema = S.array(schema)

  type getWhereFilter = {@as("id") id?: Envio.whereOperator<id>, @as("emptyField") emptyField?: Envio.whereOperator<id>, @as("status") status?: Envio.whereOperator<Enums.Status.t>, @as("optionalStatus") optionalStatus?: Envio.whereOperator<option<Enums.Status.t>>, @as("related_id") related?: Envio.whereOperator<id>, @as("optionalRelated_id") optionalRelated?: Envio.whereOperator<option<id>>, @as("tags") tags?: Envio.whereOperator<array<string>>, @as("optionalTags") optionalTags?: Envio.whereOperator<option<array<string>>>}

  let table = mkTable(
    name,
    ~fields=[
      mkField(
      "id",
      String,
      ~fieldSchema=S.string,
      ~isPrimaryKey,
      ),
      mkField(
      "emptyField",
      String,
      ~fieldSchema=S.string,
      ),
      mkField(
      "status",
      Enum({config: Enums.Status.config->Table.fromGenericEnumConfig}),
      ~fieldSchema=Enums.Status.config.schema,
      ),
      mkField(
      "optionalStatus",
      Enum({config: Enums.Status.config->Table.fromGenericEnumConfig}),
      ~fieldSchema=S.null(Enums.Status.config.schema),
      ~isNullable,
      ),
      mkField(
      "related",
      Entity({name: "RelatedEntity"}),
      ~fieldSchema=S.string,
      ~linkedEntity="RelatedEntity",
      ),
      mkField(
      "optionalRelated",
      Entity({name: "RelatedEntity"}),
      ~fieldSchema=S.null(S.string),
      ~isNullable,
      ~linkedEntity="RelatedEntity",
      ),
      mkField(
      "tags",
      String,
      ~fieldSchema=S.array(S.string),
      ~isArray,
      ),
      mkField(
      "optionalTags",
      String,
      ~fieldSchema=S.null(S.array(S.string)),
      ~isNullable,
      ~isArray,
      ),
    ],
  )

  external castToInternal: t => Internal.entity = "%identity"
}

module RelatedEntity = {
  let name = "RelatedEntity"
  let index = 1
  @genType
  type t = {id: id, name: string}

  let schema = S.object((s): t => {id: s.field("id", S.string), name: s.field("name", S.string)})

  let rowsSchema = S.array(schema)

  type getWhereFilter = {@as("id") id?: Envio.whereOperator<id>, @as("name") name?: Envio.whereOperator<string>}

  let table = mkTable(
    name,
    ~fields=[
      mkField(
      "id",
      String,
      ~fieldSchema=S.string,
      ~isPrimaryKey,
      ),
      mkField(
      "name",
      String,
      ~fieldSchema=S.string,
      ),
    ],
  )

  external castToInternal: t => Internal.entity = "%identity"
}

let userEntities = [
  module(EmptyEntity),
  module(RelatedEntity),
]->entityModsToInternal

let allEntities =
  userEntities->Js.Array2.concat(
    [module(InternalTable.DynamicContractRegistry)]->entityModsToInternal,
  )
}

@genType
module Contract1 = {
  module NewGravatar = Types.MakeRegister(Types.Contract1.NewGravatar)
  module UpdatedGravatar = Types.MakeRegister(Types.Contract1.UpdatedGravatar)
}

@genType.import(("./Types.ts", "EvmChainId"))
type chainId = [#1]

/** Contract configuration with name and ABI. */
type indexerContract = {
  /** The contract name. */
  name: string,
  /** The contract ABI. */
  abi: unknown,
  /** The contract addresses. */
  addresses: array<Address.t>,
}

/** Per-chain configuration for the indexer. */
type indexerChain = {
  /** The chain ID. */
  id: chainId,
  /** The chain name. */
  name: string,
  /** The block number to start indexing from. */
  startBlock: int,
  /** The block number to stop indexing at (if specified). */
  endBlock: option<int>,
  /** Whether the chain has completed initial sync and is processing live events. */
  isLive: bool,
  \"Contract1": indexerContract,
}

/** Strongly-typed record of chain configurations keyed by chain ID. */
type indexerChains = {
  @as("1") chain1: indexerChain,
  ethereumMainnet: indexerChain,
}

/** Metadata and configuration for the indexer. */
type indexer = {
  /** The name of the indexer from config.yaml. */
  name: string,
  /** The description of the indexer from config.yaml. */
  description: option<string>,
  /** Array of all chain IDs this indexer operates on. */
  chainIds: array<chainId>,
  /** Per-chain configuration keyed by chain ID. */
  chains: indexerChains,
}

let indexer: indexer = Main.getGlobalIndexer(~config=Generated.configWithoutRegistrations)

/** Get chain configuration by chain ID with exhaustive pattern matching. */
let getChainById = (indexer: indexer, chainId: chainId): indexerChain => {
switch chainId {
  | #1 => indexer.chains.chain1
}
}

@genType /** Register a Block Handler. It'll be called for every block by default. */
let onBlock: (
Envio.onBlockOptions<chainId>,
Envio.onBlockArgs<Envio.blockEvent, Types.handlerContext> => promise<unit>,
) => unit = (
EventRegister.onBlock: (unknown, Internal.onBlockArgs => promise<unit>) => unit
)->Utils.magic

type testIndexerProcessConfigChains = {
  @as("1") chain1?: TestIndexer.chainConfig,
}

type testIndexerProcessConfig = {
  chains: testIndexerProcessConfigChains,
}

let createTestIndexer: unit => TestIndexer.t<testIndexerProcessConfig> = TestIndexer.makeCreateTestIndexer(~config=Generated.configWithoutRegistrations, ~workerPath=NodeJs.Path.join(NodeJs.Path.dirname(NodeJs.Url.fileURLToPath(NodeJs.ImportMeta.importMeta.url)), "TestIndexerWorker.res.mjs")->NodeJs.Path.toString, ~allEntities=Generated.codegenPersistence.allEntities)
