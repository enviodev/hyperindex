---
source: cli/src/hbs_templating/codegen_templates.rs
expression: project_template.indexer_code
---
module Enums = {
  module Status = {
    @genType
    type t =
      | @as("ACTIVE") ACTIVE
      | @as("INACTIVE") INACTIVE
  }
}

module Entities = {
  type id = string

  module EmptyEntity = {
    @genType
    type t = {id: id, emptyField: id, status: Enums.Status.t, optionalStatus: option<Enums.Status.t>, related_id: id, optionalRelated_id: option<id>, tags: array<string>, optionalTags: option<array<string>>}

    type getWhereFilter = {@as("id") id?: Envio.whereOperator<id>, @as("emptyField") emptyField?: Envio.whereOperator<id>, @as("status") status?: Envio.whereOperator<Enums.Status.t>, @as("optionalStatus") optionalStatus?: Envio.whereOperator<option<Enums.Status.t>>, @as("related_id") related?: Envio.whereOperator<id>, @as("optionalRelated_id") optionalRelated?: Envio.whereOperator<option<id>>, @as("tags") tags?: Envio.whereOperator<array<string>>, @as("optionalTags") optionalTags?: Envio.whereOperator<option<array<string>>>}
  }

  module RelatedEntity = {
    @genType
    type t = {id: id, name: string}

    type getWhereFilter = {@as("id") id?: Envio.whereOperator<id>, @as("name") name?: Envio.whereOperator<string>}
  }

  type rec name<'entity> =
    | @as("EmptyEntity") EmptyEntity: name<EmptyEntity.t>
    | @as("RelatedEntity") RelatedEntity: name<RelatedEntity.t>
}

@genType
type entityHandlerContext<'entity, 'getWhereFilter> = {
  get: string => promise<option<'entity>>,
  getOrThrow: (string, ~message: string=?) => promise<'entity>,
  getWhere: 'getWhereFilter => promise<array<'entity>>,
  getOrCreate: 'entity => promise<'entity>,
  set: 'entity => unit,
  deleteUnsafe: string => unit,
}

@genType.import(("./Types.ts", "HandlerContext"))
type handlerContext = {
  log: Envio.logger,
  effect: 'input 'output. (Envio.effect<'input, 'output>, 'input) => promise<'output>,
  isPreload: bool,
  chain: Internal.chainInfo,
  @as("EmptyEntity") emptyEntity: entityHandlerContext<Entities.EmptyEntity.t, Entities.EmptyEntity.getWhereFilter>,
  @as("RelatedEntity") relatedEntity: entityHandlerContext<Entities.RelatedEntity.t, Entities.RelatedEntity.getWhereFilter>,
}

@genType.import(("./Types.ts", "EvmChainId"))
type chainId = [#1]

/** Contract configuration with name and ABI. */
type indexerContract = {
  /** The contract name. */
  name: string,
  /** The contract ABI. */
  abi: unknown,
  /** The contract addresses. */
  addresses: array<Address.t>,
}

/** Per-chain configuration for the indexer. */
type indexerChain = {
  /** The chain ID. */
  id: chainId,
  /** The chain name. */
  name: string,
  /** The block number to start indexing from. */
  startBlock: int,
  /** The block number to stop indexing at (if specified). */
  endBlock: option<int>,
  /** Whether the chain has completed initial sync and is processing live events. */
  isLive: bool,
  \"Contract1": indexerContract,
}

/** Strongly-typed record of chain configurations keyed by chain ID. */
type indexerChains = {
  @as("1") chain1: indexerChain,
  ethereumMainnet: indexerChain,
}

/** Metadata and configuration for the indexer. */
type indexer = {
  /** The name of the indexer from config.yaml. */
  name: string,
  /** The description of the indexer from config.yaml. */
  description: option<string>,
  /** Array of all chain IDs this indexer operates on. */
  chainIds: array<chainId>,
  /** Per-chain configuration keyed by chain ID. */
  chains: indexerChains,
}

/** Get chain configuration by chain ID with exhaustive pattern matching. */
let getChainById = (indexer: indexer, chainId: chainId): indexerChain => {
switch chainId {
  | #1 => indexer.chains.chain1
}
}

@genType /** Register a Block Handler. It'll be called for every block by default. */
let onBlock: (
Envio.onBlockOptions<chainId>,
Envio.onBlockArgs<Envio.blockEvent, handlerContext> => promise<unit>,
) => unit = (
HandlerRegister.onBlock: (unknown, Internal.onBlockArgs => promise<unit>) => unit
)->Utils.magic

type testIndexerProcessConfigChains = {
  @as("1") chain1?: TestIndexer.chainConfig,
}

type testIndexerProcessConfig = {
  chains: testIndexerProcessConfigChains,
}

/** Test indexer type with process method and chain info. */
type testIndexer = {
  /** Process blocks for the specified chains and return progress with changes. */
  process: testIndexerProcessConfig => promise<TestIndexer.processResult>,
  /** Array of all chain IDs this indexer operates on. */
  chainIds: array<chainId>,
  /** Per-chain configuration keyed by chain ID. */
  chains: indexerChains,
}
