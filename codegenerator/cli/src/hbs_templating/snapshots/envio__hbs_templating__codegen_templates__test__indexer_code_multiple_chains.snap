---
source: cli/src/hbs_templating/codegen_templates.rs
expression: project_template.indexer_code
---
module Enums = {

}

module Entities = {
  type id = string

  module EmptyEntity = {
    @genType
    type t = {id: id, emptyField: id}

    type getWhereFilter = {@as("id") id?: Envio.whereOperator<id>, @as("emptyField") emptyField?: Envio.whereOperator<id>}
  }
}

@genType
module Contract1 = {
  module NewGravatar = Types.MakeRegister(Types.Contract1.NewGravatar)
  module UpdatedGravatar = Types.MakeRegister(Types.Contract1.UpdatedGravatar)
}

@genType
module Contract2 = {
  module NewGravatar = Types.MakeRegister(Types.Contract2.NewGravatar)
  module UpdatedGravatar = Types.MakeRegister(Types.Contract2.UpdatedGravatar)
}

@genType.import(("./Types.ts", "EvmChainId"))
type chainId = [#1 | #2]

/** Contract configuration with name and ABI. */
type indexerContract = {
  /** The contract name. */
  name: string,
  /** The contract ABI. */
  abi: unknown,
  /** The contract addresses. */
  addresses: array<Address.t>,
}

/** Per-chain configuration for the indexer. */
type indexerChain = {
  /** The chain ID. */
  id: chainId,
  /** The chain name. */
  name: string,
  /** The block number to start indexing from. */
  startBlock: int,
  /** The block number to stop indexing at (if specified). */
  endBlock: option<int>,
  /** Whether the chain has completed initial sync and is processing live events. */
  isLive: bool,
  \"Contract1": indexerContract,
  \"Contract2": indexerContract,
}

/** Strongly-typed record of chain configurations keyed by chain ID. */
type indexerChains = {
  @as("1") chain1: indexerChain,
  ethereumMainnet: indexerChain,
  @as("2") chain2: indexerChain,
}

/** Metadata and configuration for the indexer. */
type indexer = {
  /** The name of the indexer from config.yaml. */
  name: string,
  /** The description of the indexer from config.yaml. */
  description: option<string>,
  /** Array of all chain IDs this indexer operates on. */
  chainIds: array<chainId>,
  /** Per-chain configuration keyed by chain ID. */
  chains: indexerChains,
}

let indexer: indexer = Main.getGlobalIndexer(~config=Generated.configWithoutRegistrations)

/** Get chain configuration by chain ID with exhaustive pattern matching. */
let getChainById = (indexer: indexer, chainId: chainId): indexerChain => {
switch chainId {
  | #1 => indexer.chains.chain1
  | #2 => indexer.chains.chain2
}
}

@genType /** Register a Block Handler. It'll be called for every block by default. */
let onBlock: (
Envio.onBlockOptions<chainId>,
Envio.onBlockArgs<Envio.blockEvent, Types.handlerContext> => promise<unit>,
) => unit = (
EventRegister.onBlock: (unknown, Internal.onBlockArgs => promise<unit>) => unit
)->Utils.magic

type testIndexerProcessConfigChains = {
  @as("1") chain1?: TestIndexer.chainConfig,
  @as("2") chain2?: TestIndexer.chainConfig,
}

type testIndexerProcessConfig = {
  chains: testIndexerProcessConfigChains,
}

let createTestIndexer: unit => TestIndexer.t<testIndexerProcessConfig> = TestIndexer.makeCreateTestIndexer(~config=Generated.configWithoutRegistrations, ~workerPath=NodeJs.Path.join(NodeJs.Path.dirname(NodeJs.Url.fileURLToPath(NodeJs.ImportMeta.importMeta.url)), "TestIndexerWorker.res.mjs")->NodeJs.Path.toString, ~allEntities=Generated.codegenPersistence.allEntities)
